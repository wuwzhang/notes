{"title":"第9期","content":"## 2021/01/19\n\n## 每日资讯\n### 1. 你不知道的blob\n**如何区分返回内容是文件流还是json数据?** 看到这个问题，你有什么想法吗？ 没错，就是今天我们准备介绍的`blob`\n```js\nawait (await fetch(url)).blob();\n// Blob {size: 100, type: \"application/json\"}\n// Blob {size: 73226, type: \"image/jpeg\"}\n```\n\n`Blob`对象表示一个不可变、原始数据的类文件对象，通常是影像、声音或多媒体文件。它的数据可以按文本或二进制的格式进行读取，也可以转换成 `ReadableStream` 来用于数据操作\n\n`blob`从`ES5`开始就逐步被浏览器支持的特性，它让我们能够比较方便地处理文件式的二进制数据\n\n![](image-kk3b77z6.png)\n\n#### 使用场景\n- 网页中预览本地图片\n\t- 可以通过`Data URL（base64）`或者`Blob URL`实现图片预览\n\t- `Base64`是一种基于`64`个可打印字符来表示二进制数据的表示方法，它常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 `MIME` 的电子邮件及 `XML` 的一些复杂数据\n\t- 如果图片颜色丰富，则不适合使用`base64`展示，因为经过编码后，字符串体积会很大\n```js\n<input type=\"file\" accept=\"image/*\" onchange=\"selectFile(event)\">\n\n\t// data url\nconst reader = new FileReader();\nconst url = reader.readAsDataURL(event.target.files[0]);\n\n // blob url\nconst url = window.URL.revokeObjectURL(imgUrl);\n```\n- 分片上传\n\t- File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传\n```js\nconst file = new File([\"a\".repeat(1000000)], \"test.txt\");\n\nconst chunkSize = 40000;\nconst url = \"https://httpbin.org/post\";\n\nasync function chunkedUpload() {\n  for (let start = 0; start < file.size; start += chunkSize) {\n      const chunk = file.slice(start, start + chunkSize + 1);\n      const fd = new FormData();\n      fd.append(\"data\", chunk);\n\n      await fetch(url, { method: \"post\", body: fd }).then((res) =>\n        res.text()\n      );\n  }\n}\n```\n- 动态创建模板\n\t- 现代浏览器对`ES Modules`已经有了良好的支持，可以使用`Blob`动态创建模板\n```js\n<script type=\"module\">\nfunction importCode(code) {\n  const blob = new Blob([code], {type: \"text/javascript\"});\n\n  const script = document.createElement('script');\n  document.body.appendChild(script);\n  script.setAttribute('type', 'module');\n\n  script.src = URL.createObjectURL(blob);\n\n  return import(script.src);\n}\n\nconst code = `\n  export default {\n    foo: 'bar',\n  }\n`;\n\nimportCode(code).then((m) => {\n  console.log(m.default); // {foo: 'bar'}\n});\n</script>\n```\n- 图片压缩\n\t- 使用我们可以利用 `Canvas` 对象提供的 `toDataURL()` 方法进行图片压缩\n\t- 将`canvas`对象用`toBlob`转成二进制对象发送给服务器，比起用`toDataURL()`给转成`base64`，体积更小，服务器不需要额外转换，处理速度更快\n```js\n// compress.js\nconst MAX_WIDTH = 800; // 图片最大宽度\n\nfunction compress(base64, quality, mimeType) {\n  let canvas = document.createElement(\"canvas\");\n  let img = document.createElement(\"img\");\n  img.crossOrigin = \"anonymous\";\n  return new Promise((resolve, reject) => {\n    img.src = base64;\n    img.onload = () => {\n      let targetWidth, targetHeight;\n      if (img.width > MAX_WIDTH) {\n        targetWidth = MAX_WIDTH;\n        targetHeight = (img.height * MAX_WIDTH) / img.width;\n      } else {\n        targetWidth = img.width;\n        targetHeight = img.height;\n      }\n      canvas.width = targetWidth;\n      canvas.height = targetHeight;\n      let ctx = canvas.getContext(\"2d\");\n      ctx.clearRect(0, 0, targetWidth, targetHeight); // 清除画布\n      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n      let imageData = canvas.toDataURL(mimeType, quality / 100);\n      resolve(imageData);\n    };\n  });\n}\n```\n\t\n```js\n// 转换为 Blob 对象\nfunction dataUrlToBlob(base64, mimeType) {\n  let bytes = window.atob(base64.split(\",\")[1]);\n  let ab = new ArrayBuffer(bytes.length);\n  let ia = new Uint8Array(ab);\n  for (let i = 0; i < bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i);\n  }\n  return new Blob([ab], { type: mimeType });\n}\n```\n- 结合`svg foreignObject`构建图片\n- 创建`a`标签实现文件下载\n- 使用`fetch`或`XMLHttpRequest`下载互联网文件\n\n#### 相关文章\n- [MDN - blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)\n- [你不知道的 Blob](https://mp.weixin.qq.com/s/lQKTCS_QB0E62SK9oXD4LA)\n- [超好用的Blob对象！](https://github.com/akira-cn/FE_You_dont_know/issues/12)\n\n## 30 seconds of code\n### 目标\n剔除对象中指定数组中的键名\n\n### 样例输出: \n```js\nomit({ a: 1, b: '2', c: 3 }, ['b']); // { 'a': 1, 'c': 3 }\n```\n\n### 参考实现\n```js\nconst omit = (obj, arr) =>\n  Object.keys(obj)\n    .filter(k => !arr.includes(k))\n    .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});\n```\n\n## 每日一问\n\n> 以下代码的运行结果是？\n\n```js\nclass Counter {\n  #number = 10\n\n  increment() {\n    this.#number++\n  }\n\n  getNum() {\n    return this.#number\n  }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)\n```\n- A &nbsp;&nbsp;`10` \n- B &nbsp;&nbsp;`11`\n- C &nbsp;&nbsp;`undefined` \n- D &nbsp;&nbsp;`SyntaxError`\n\n## 每日二问\n> 以下代码的运行结果是？\n\n```js\nconst user = {\n\temail: \"my@email.com\",\n\tupdateEmail: email => {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail(\"new@email.com\")\nconsole.log(user.email)\n```\n\n- A &nbsp;&nbsp;`my@email.com` \n- B &nbsp;&nbsp;`new@email.com`\n- C &nbsp;&nbsp;`undefined` \n- D &nbsp;&nbsp;`ReferenceError`\n### 昨天的答案\n#### 第一题\n- D\n\n#### 第二题\n- A\n- 函数`add`是一个返回 返回箭头函数的箭头函数 的箭头函数。当我们尝试在最后一个箭头函数中获取 `x`, `y` 和 `z` 的值，`JS` 引擎根据作用域链去找 `x` 和 `y` 的值。得到 `4 5 6`\n","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-02-22T07:02:57.746Z","updatedAt":"2021-02-22T07:13:53.291Z","trashed":false,"_id":"note:i-gyn0zKp","_rev":"4-0210a4886f0d2f41412bfb360782783e"}