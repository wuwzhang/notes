{"_id":"note:UGMeGSay6","title":"第59期","content":"## 2021/07/13\n## 每周资讯 - 第`59`期\n### 1. CSS 奇思妙想 | 全兼容的毛玻璃效果\n通过本文，你能了解到\n\n1. 最基本的使用 CSS `backdrop-filter` 实现磨砂玻璃(毛玻璃)的效果\n2. 在至今不兼容`backdrop-filter`的 firefox 浏览器，如何利用一些技巧性的操作，巧妙的同样实现毛玻璃效果，让这个效果真正能运用在业务当中\n#### 什么是`backdrop-filter`\n`backdrop-filter` CSS 属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。\n\nbackdrop-filter 与 filter 非常类似，可以取的值都是一样的，但是一个是作用于整个元素，一个是只作用于元素后面的区域。\n\n##### `backdrop-filter`与`filter`对比\n我们使用`backdrop-filter`与`filter`同时实现一个毛玻璃效果作为对比，伪代码如下：\n\n```html\n<div class=\"bg\">\n    <div>Normal</div>\n    <div class=\"g-filter\">filter</div>\n    <div class=\"g-backdrop-filter\">backdrop-filter</div>\n</div>\n```\n```scss\n.bg {\n    background: url(image.png);\n    \n    & > div {\n        width: 300px;\n        height: 200px;\n        background: rgba(255, 255, 255, .7);\n    }\n    .g-filter {\n        filter: blur(6px);\n    }\n    .g-backdrop-filter {\n        backdrop-filter: blur(6px);\n    }\n}\n```\n[CodePen Demo -- filter 与 backdrop-filter 对比](https://codepen.io/Chokcoco/pen/WNjebrr)\n\n在`backdrop-filter`之前，想实现上述的只给元素背景添加滤镜效果还是非常困难的，并且，对于静态画面还好，如果背景还是可以滚动的动态背景，通常 CSS 是无能为力的。\n\n`backdrop-filter`正是为了给元素后的内容添加滤镜而不影响元素本身而诞生的。使用它可以非常方便的实现磨砂玻璃效果（毛玻璃）！\n\n#### `backdrop-filter`的兼容性\n`backdrop-filter`其实已经诞生挺久了，然而，`firefox`至今都不兼容它！\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3844c5f068fb498e84759db843394e64~tplv-k3u1fbpfcp-zoom-1.image)\n\n对于部分已经放弃了 IE 的 PC 端业务而言，firefox 还是需要兼容的，想要让使用 `backdrop-filter`实现毛玻璃效果应用落地，firefox 的兼容问题必须得解决。\n\n#### 在 firefox 中实现毛玻璃效果\nOK，本文的重点就是在于如何在 firefox 中，不使用`backdrop-filter`而尽可能的还原毛玻璃的效果。\n\n首先看一下，如果是正常使用`backdrop-filter`，还是上述的例子效果如下，是没有毛玻璃效果的：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c3cf43d22c54ed6bd8f30c463723165~tplv-k3u1fbpfcp-zoom-1.image)\n\n##### 使用 background-attachment: fixed 兼容静态背景图\n如果在 firefox 上想使用毛玻璃效果。应用毛玻璃元素的背景只是一张静态背景图，其实方法是有很多的。\n\n我们只需在元素的背后，叠加一张同样的图片，利用`background-attachment: fixed`将叠加在元素下面的图片定位到与背景相同的坐标，再使用`filter: blur()` 对其进行模糊处理即可。\n\n伪代码如下：\n```html\n<div class=\"g-glossy\">frosted glass effect </div>\n```\n\n```scss\n$img: 'https://static.pexels.com/photos/373934/pexels-photo-373934.jpeg';\n\nbody {\n    height: 100vh;\n    display: flex;\n    background-image: url($img);\n    background-repeat: no-repeat;\n    background-attachment: fixed;\n    background-size: cover;\n}\n\n.g-glossy {\n    position: relative;\n    width: 600px;\n    height: 300px;\n    background-color: rgba(255, 255, 255, 0.5);\n    overflow: hidden;\n    z-index: 10;\n    \n    &::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        background-image: url($img);\n        background-repeat: no-repeat;\n        background-attachment: fixed;\n        background-size: cover;\n        filter: blur(10px);\n        z-index: -1;\n    }\n}\n```\n此方法也是在没有`backdrop-filter`之前，在各个浏览器想实现简单毛玻璃效果最常用的方法之一。\n[CodePen Demo -- 使用 background-attachment: fixed | filter: bulr() 实现毛玻璃效果](https://codepen.io/Chokcoco/pen/XWRrVma)\n\n使用 background-attachment: fixed 兼容静态背景图的缺点\n不过这种方法也有两个缺点：\n\n1. 由于使用了伪元素叠加了一层背景，因为层级关系，父元素的 background 是在最下层的，所以元素本身的背景色其实并没有被充分体现，可以对比下两种方法的实际效果图：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd5d549e72254958810f2559ef61e648~tplv-k3u1fbpfcp-zoom-1.image)\n\n解决方案是再通过另外一个伪元素再叠加一层背景色，这个背景色应该是原本赋值给父元素本身的。\n\n叠加之后的效果如下：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff360c5bd02b4a4fbd72977d73710a5d~tplv-k3u1fbpfcp-zoom-1.image)\n\n2. 上述效果已经非常接近了，硬要挑刺的话，就是应用了模糊滤镜的伪元素的边缘有白边瑕疵，这一点其实是滤镜本身的问题，也非常好解决，我们只需要将伪元素的范围扩大一点即可：\n\n```scss\n.g-glossy {\n    overflow: hidden;\n    ....\n    &::before {\n        content: \"\";\n        position: absolute;\n        top: -100px;\n        left: -100px;\n        right: -100px;\n        bottom: -100px;\n    }\n}\n```\n\n定位的代码由`top: 0px;`改为`top: -100px`，四个方位都是如此即可。如此一来，就能做到基本上是百分百的模拟。\n\n##### 使用 moz-element() 配合 filter: blur() 实现复杂背景毛玻璃效果\n下面这种方法就非常巧妙了，正常而言，运用毛玻璃效果的背景元素，都不是一张图片那么简单！背后通常都是整个页面复杂的结构，多层 DOM 的嵌套。\n\n那么通过叠加一张简单的图片，就无法奏效了，我们得想办法模拟整个 DOM 元素。\n\n而恰好，在 Firefox 中，有这么一个属性 -- `-moz-element()`。\n\n何为`-moz-element()`？[MDN-element](https://developer.mozilla.org/en-US/docs/Web/CSS/element()) 的解释是，CSS 函数`element()`定义了一个从任意的 HTML 元素中生成的图像`<image>`值。该图像值是实时的，这意味着如果被指定的 HTML 元素被更改，应用了该属性的元素的背景也会相应更改。\n\n它其实是个草案规范，但是一直以来，只有 Firefox 支持它 \n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4204c0fee5c24d769c395ab449f24908~tplv-k3u1fbpfcp-zoom-1.image)\n\n它有什么作用呢？\n\n##### -moz-element() 如何使用\n那么`-moz-element()`如何使用呢？简而言之，它能够复制一个元素内部渲染出来的 UI，并且能够实时同步变化。\n\n假设我们有这样一个简单的结构，元素背景和内容都在运动：\n\n```html\n<div id=\"bg\" class=\"g-normal\">\n    <p>Content</p>\n</div>\n```\n\n```scss\n.g-normal {\n    margin: auto;\n    width: 200px;\n    height: 200px;\n    animation: change 5s infinite;\n    background: linear-gradient(deeppink, yellowgreen);\n}\n\np {\n    animation: move 5s infinite;\n}\n\n@keyframes change {\n    0% {\n        filter: hue-rotate(0);\n    }\n    100% {\n        filter: hue-rotate(360deg);\n    }\n}\n\n@keyframes move {\n    0% {\n        transform: translate(0, 0);\n    }\n    100% {\n        transform: translate(150px, 150px);\n    }\n}\n```\n\n![](https://user-images.githubusercontent.com/8554143/123617162-8d486700-d839-11eb-9b0c-f090cbc52abd.gif)\n\n我们就假设这个结构就是我们页面某一块的内容，然后，我们就可以使用 `background: -moz-element(#id)` 这种方式，将这个元素内绘制的 UI 内容完全拷贝至另外一个元素，看看效果。\n\n我们添加一个元素`<div class=\"g-element-copy\"></div>`，在这个元素内模拟 #bg 内的内容：\n\n```html\n<div id=\"bg\" class=\"g-normal\">\n    <p>Content</p>\n</div>\n<div class=\"g-element-copy\"></div>\n```\n```scss\n.g-element-copy {\n    margin: auto;\n    width: 200px;\n    height: 200px;\n    // 核心代码\n    background: -moz-element(#bg);\n}\n```\n\n它可以完全复制另外一个元素内绘制出来的 UI，并且能追踪实时变化：\n![](https://user-images.githubusercontent.com/8554143/123618303-a69de300-d83a-11eb-9ddd-4b6b929fcdac.gif)\n\n[CodePen Demo -- -moz-element Demo(Firefox Only)](https://codepen.io/Chokcoco/pen/jOmOPPL)\n\n#### 在 firefox 中使用 element 复制 UI，用作毛玻璃元素背景\n这样，有了上面的铺垫，下面的内容就比较好理解了。\n\n和上述的`background-attachment: fixed`方案对比，我们还是通过伪元素叠加一层背景，只不过背景内的内容由单纯一张图片，变成了由`-moz-element()`复制的整段 UI 内容。\n\n其次，上面的方案我们使用`background-attachment: fixed`使背景图和伪元素内叠加的图片的位置对齐，在这里，我们需要借助 Javascript 进行简单的运算，确定背景内容元素的相关位置，计算对齐量。\n\n来看这样一个 DEMO：\n\n```html\n<div id=\"bg\" class=\"bg\">\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n    <div>模拟真实 DOM</div>\n</div>\n<div class=\"g-glossy\">frosted glass effect </div>\n<div class=\"g-glossy-firefox\"></div>\n```\n\n其中，`.g-glossy`是在正常情况下`backdrop-filter`兼容时，我们的毛玻璃元素，而`.g-glossy-firefox`则是不兼容`backdrop-filter`时，我们需要模拟整个 DOM 背景 UI时候的元素，可以通过 CSS 特性检测`CSS @support`进行控制：\n核心 CSS 代码：\n\n```scss\n.bg {\n    // 整个页面的 DOM 结构\n}\n\n.g-glossy {\n    position: fixed;\n    width: 600px;\n    height: 300px;\n    background-color: rgba(255, 255, 255, 0.5);\n    backdrop-filter: blur(10px);\n}\n\n.g-glossy-firefox {\n    display: none;\n}\n\n@supports (background: -moz-element(#bg)) {\n    .g-glossy-firefox {\n        display: block;\n        position: fixed;\n        width: 600px;\n        height: 300px;\n        background: -moz-element(#bg) no-repeat;\n        filter: blur(10px);\n    }\n}\n```\n简单解读一下：\n\n1. 对于兼容`backdrop-filter`的，`.g-glossy`内的代码将直接生效，并且`.g-glossy-firefox`不会展示\n2. 对于 Firefox 浏览器，因为`backdrop-filter`必然不兼容，所以`.g-glossy`内的`backdrop-filter: blur(10px)`不会生效，而`@supports (background: -moz-element(#bg))`内的样式会生效，此时`.g-glossy-firefox`将会利用 `background: -moz-element(#bg) no-repeat`; 模拟`id`为`bg`的元素\n\n当然，这里我们需要借助一定的`JavaScript`代码，计算我们的模拟页面 UI 的元素 `.g-glossy-firefox`相对它模拟的`#bg`元素，也就是页面布局的一个定位偏差：\n\n```js\n$(function() {\n        let blur = $('.g-glossy-firefox')[0].style;\n        let offset = $('.g-glossy').eq(0).offset();\n\n        function updateBlur() {\n            blur.backgroundPosition = \n                `${-window.scrollX - offset.left}px ` + \n                `${-window.scrollY - offset.top}px`;\n        }\n        document.addEventListener('scroll', updateBlur, false), updateBlur();\n});\n```\n\nOK，至此，我们就能完美的在 Firefox 上也实现毛玻璃的效果了：\n![](https://user-images.githubusercontent.com/8554143/123645631-14f19e00-d859-11eb-9aaa-3b0032da89e0.gif)\n\n它相对于上面的第一种方案而言，最大的不同之处在于，它可以模拟各式各样的背景元素，背景元素可以不仅仅只是一张图片！它可以是各种复杂的结构！\n\n这种方案是我的 CSS 群中，风海流 同学提供的一种思路，非常的巧妙，并且，他自己也对这种方案进行了完整的阐述，你可以戳这里看看：在网页中实现标题栏「毛玻璃」效果，本文也是经过他的同意，重新整理发出。\n\n上述效果的完整代码，你可以戳这里：\n\n[CodePen Demo -- 兼容 Firefox 的复杂背景毛玻璃（磨砂玻璃）效果](https://codepen.io/Chokcoco/pen/ExWqaQG)\n\n#### 总结一下\n简单对上述内容进行一个总结：\n\n1. 你可以使用 backdrop-filter 对兼容它的浏览器非常简单的实现毛玻璃（磨砂玻璃）效果\n2. 对于不兼容 backdrop-filter 的浏览器，如果它只是简单背景，可以使用 background-attachment: fixed 配合 filter: blur() 进行模拟\n3. 对于 firefox 浏览器，你还可以使用 moz-element() 配合 filter: blur() 实现复杂背景毛玻璃效果\n4. 对于不兼容的上述 3 种效果的其他浏览器，设置了毛玻璃效果的元素，可以通过设置类似 background: rgba(255, 255, 255, 0.5) 的样式，使之回退到半透明效果，也算一种非常合理的降级效果，不会引起 Bug\n\n#### 相关文章\n- [CSS 奇思妙想 | 全兼容的毛玻璃效果](https://juejin.cn/post/6979391400844460068)\n\n### 2. 2021 GMTC 讲师 PPT 合集 - 早早聊收藏\n#### 相关文章\n- [2021 GMTC 讲师 PPT 合集 - 早早聊收藏](https://www.yuque.com/zaotalk/nt/gcdkag)\n\n## 30 seconds of code\n### 目标\n实现从左往右的异步组合函数\n### 样例输出: \n```js\nconst sum = pipeAsyncFunctions(\n  x => x + 1,\n  x => new Promise(resolve => setTimeout(() => resolve(x + 2), 1000)),\n  x => x + 3,\n  async x => (await x) + 4\n);\n(async() => {\n  console.log(await sum(5)); // 15 (after one second)\n})();\n```\n### 参考实现\n```js\nconst pipeAsyncFunctions = (...fns) =>\n  arg => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));\n```\n## 每日一问\n> 以下代码的运行结果为\n\n```js  \nvar a = 10;\n(function () {\n    console.log(a)\n    a = 5\n    console.log(window.a)\n    var a = 20;\n    console.log(a)\n})()\n```\n\n## 每日二问\n> 以下代码的运行结果为\n\n```js    \nvar obj = {\n    '2': 3,\n    '3': 4,\n    'length': 2,\n    'splice': Array.prototype.splice,\n    'push': Array.prototype.push\n}\nobj.push(1)\nobj.push(2)\nconsole.log(obj)\n```\n\n### 上期的答案\n#### 第一题\n> 下面代码中 a 在什么情况下会打印 1？\n\n```js    \nvar a = ?;\nif(a == 1 && a == 2 && a == 3){\n \tconsole.log(1);\n}\n```\n\n```js\n// a1\nvar a = {\n  i: 1,\n  toString() {\n    return a.i++;\n  }\n}\n\n// a2\nlet a = [1,2,3];\na.toString = a.shift;\n\n// a3\nvar a = {num:0};\na.valueOf = function(){\n  return ++a.num\n}\n\n// a4\nvar a = {[Symbol.toPrimitive]: ((i) => () => ++i) (0)};\n```\n\n#### 每日二问\n> 如何用 css 或 js 实现多行文本溢出省略效果，考虑兼容性\n\n```less\n// 单行：\noverflow: hidden;\ntext-overflow:ellipsis;\nwhite-space: nowrap;\n// 多行：\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3; //行数\noverflow: hidden;\n// 兼容：\np {\n  position: relative; \n  line-height: 20px; \n  max-height: 40px;\n  overflow: hidden;\n}\np::after {\n  content: \"...\"; \n  position: absolute; \n  bottom: 0; right: 0; \n  padding-left: 40px;\n  background: linear-gradient(to right, transparent, #fff 55%);\n}\n```\n[小技巧！CSS 整块文本溢出省略特性探究](https://juejin.cn/post/6938583040469762055)","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-07-12T15:38:53.318Z","updatedAt":"2021-07-12T16:25:38.731Z","trashed":false,"_rev":"hdDRRTeMs"}