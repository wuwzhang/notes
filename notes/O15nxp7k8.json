{"title":"webpack","content":"`webpack` 概念笔记\n===\n\n## 是什么\n- 静态模块打包器\n- 递归构建依赖关系图\n- 将模块打包成一个或多个`bundle`\n### `entry`\n  - 文件入口配置项：`String`/`Object`/`Array`\n  - 一个或多个\n  - 默认`./src`\n### `output`\n  - 文件出口配置\n  - 默认`./dist`\n### `loader`\n - `webpack`自身只能`js`\n - 处理非`js`文件将其转换为依赖图可以直接引用的模块\n### `mode`\n  - `development`/`production`\n  - 告知`webpack`开启相应的内置优化\n### `plugins`\n  - 赋能，支持更多功能\n### `manifest`\n#### `Runtime`\n  - 包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑\n#### `manifest`\n  - `import`和`require`会转化为`__webpack_require__`\n  - 当编译器(`compiler`)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为`Manifest`\n  - 通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块\n### 模块热替换（`HMR`）\n  - 程序运行中修改模块，无需更新整个页面\n\n\n## Webpack 打包后的代码是怎样的？\n### 分析主流程\n其实就是一个 IIFE\n莫慌，我们一点点拆分开看，其实总体的文件就是一个 IIFE——立即执行函数。\n```js\n(function(modules) { // webpackBootstrap\n\t// The module cache\n\tvar installedModules = {};\n\tfunction __webpack_require__(moduleId) {\n    // ...省略细节\n\t}\n\t// 入口文件\n\treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n})\n({\n\n \"./src/index.js\": (function(module, __webpack_exports__, __webpack_require__) {}),\n  \"./src/sayHello.js\": (function(module, __webpack_exports__, __webpack_require__) {})\n});\n\n```\n\nhttps://juejin.cn/post/6937086236926410783","tags":[],"folderPathname":"/font/workflow","data":{},"createdAt":"2020-08-07T02:51:15.683Z","updatedAt":"2021-03-11T09:55:16.619Z","trashed":false,"_id":"note:O15nxp7k8","_rev":"13-f265ef1518a74e382efccca7cb0fc22c"}