{"title":"ES6语法规范","content":"`es6`语法规范\n===\n\n## 引用\n> 对所有变量使用`const`代替`var`, 如果一定要改变引用值，使用`let`代替`var`\n\n```tsx\n// bad\nvar a = 1;\n\n// good\nconst b = 1;\n\n// bad\nvar flag = 0;\nif (cond) {\n  flag = 0\n}\n\n// good \nlet flag = 1;\nif (cond) {\n  flag = 0;\n}\n\n```\n\n## 对象\n\n### 创建字面量\n``` tsx\n// bad\nconst item = new Object();\n\n// good\nconst item = {}\n```\n\n### 创建带计算的属性名\n```tsx\nconst getKey = (v) => `key${v}`;\n\n// bad\nconst obj = {\n  id: 1,\n};\nobj[getKey(1)] = \"wuw\";\n\n// good\nconst obj = {\n  id: 2,\n  [getKey(2)] = \"polm\",\n};\n```\n\n### 速记语法\n```tsx\n// bad\nconst name = \"wuw\";\nconst obj = {\n  name: name,\n};\n\n// good\nconst obj = {\n  name\n}\n\n\n// bad\nconst obj1 = {\n  name: \"wuw\",\n  getName: (v) => obj1.name,\n};\n\n// good\nconst obj1 = {\n  name: \"wuw\",\n  getName() {\n    return obj1.name;\n  },\n};\n```\n\n### 引号使用，会改变语法高亮\n\n```ts\n// bad\nconst obj = {\n  \"id\": 1,\n  \"name\": \"wuw\",\n  \"data-test\": \"haha\"\n}\n\n// good\nconst obj = {\n  id: 1,\n  name: \"wuw\",\n  \"data-test\": \"haha\"\n}\n```\n### 使用`...`优先于`Object.assign`\n```tsx\n// very bad\nconst obj = { a: 1, b: 2 };\nconst copy = Object.assign(original, { c: 3 });\ndelete copy.a;\n\n// good\nconst obj = { a: 1, b: 2 };\nconst copy = { ...obj, c: 3 };\n\nconst { a, ...noA } = copy;\n```\n\n## 数组\n### 数组创建\n```ts\n// bad\nconst arr = new Array();\n\n// good\nconst arr = [];\n```\n\n### 数组复制\n```ts\n// bad\nconst copy = [];\nfor (let i = 0; const len = item.length; i < len; i++) {\n  copy[i] = item[i];\n}\n\n// good\nconst copy = [...item];\n```\n\n### 数组添加元素\n```ts\nconst a = [];\n\n// bad\na[a.length] = 1;\n\n// good\na.push(1);\n```\n\n### 类数组转换\n```ts\nconst set = new Set();\n\n// good\nconst arr = Array.from(set);\n\n// best\nconst arr = [...set];\n```\n\n## 解构\n\n### 对象结构\n```tsx\n// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n \n  return `${firstName} ${lastName}`;\n}\n \n// good\nfunction getFullName(user) {\n  const { firstName, lastName } = user;\n  return `${firstName} ${lastName}`;\n}\n \n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\n```\n\n### 数组结构\n```ts\nconst arr = [1, 2, 3];\n\n// bad\nconst a = arr[0];\nconst b = arr[1];\n\n// good\nconst [a, b] = arr;\n```\n### 出入参\n- 入参超过`3`个时，使用对象代替元素, 可以不用考虑顺序\n```ts\n// bad\nfunction func(a1, a2, a3, a4) {\n  \n}\n\n// good\nfunction func({ a1, ...res}) {\n  \n}\n```\n\n- 出参超过`3`个，使用对象代替数组, 可以不用考虑顺序\n```ts\nfunction func() {\n  return [a1, a2, a3, a4];\n}\n\n// good\nfunction func() {\n  return { a1, a2, a3, a4 };\n}\n```\n\n### 字符串\n```ts\n// bad - 模板字符串应该包含变量\nconst str = `aaa`;\n\n// good\nconst str = \"aaa\"\n\n// bad\nconst name = \"wuw\";\nconst str1 = [\"hi\", name, '~'].join();\n\n// bad\nconst name = \"wuw\";\nconst str1 = \"hi\" + name + \"~\";\n\n// bad\nconst name = \"wuw\";\nconst str1 = `hi ${ name } ~`;\n\n// good\nconst name = \"wuw\";\nconst str1 = `hi ${name} ~`;\n```\n\n## 函数\n### 使用命名函数代替函数声明\n- 函数声明会被变量提升\n- 可读性和可维护性造成影响\n\n```ts\n// bad\nfunction func1() {\n  \n}\n\n// good\nconst func1 = () => {\n  \n}\n```\n\n### 不在非函数代码块中进行函数声明\n```ts\n// bad\nif (cond) {\n  function fun() {\n    \n  }\n}\n\n// good \nlet func;\nif (cond) {\n  func = () => {\n    \n  }\n}\n```\n\n### 函数参数不要使用`arguments`, 会覆盖原有作用域的`arguments`, 使用`...`代替\n```ts\n// very bad\nfunction (a1, arguments) {\n  \n}\n\n// good\nfunction (a1, ...args) {\n  \n}\n```\n\n### 函数默认值\n```ts\n// bad - 会改变对象false值\nfunction func(opts) {\n  opts = opts || {};\n}\nfunc(0)  // {}\nfunc(NaN)  // {}\nfunc(null)  // {}\nfunc(undefine)  // {}\n\n\n// good\nfunction func(opts = {}) {\n  \n}\n\nfunc(0)  // 0\nfunc(NaN)  // NaN\nfunc(null)  // null\nfunc(undefine)  // {}\n```\n\n### 将有默认值的参数放在最后\n\n## 箭头函数\n```ts\n// bad\n[1, 2].map((v) => v + 1);\n\n// good\n[1, 2].map(v => v + 1);\n[1, 2].map(v => (\n  `llllllllllllllllllllllllllllllllllll${v}onggggggggggggggggggg`\n))\n[1, 2].map(v => {\n  const u = v + 1;\n  return u * v;\n})\n```\n\n## 构造函数\n避免空的构造函数\n```ts\n// bad\nconstructor(...args) {\n  super(...args);\n}\n\n// good\nconstructor(...args) {\n  super(...args);\n  this.name = \"wuw\";\n}\n```\n\n## 模块\n```ts\n// bad\nconst module1 = require('./Module');\nmodel.exports = module1.test;\n\n// good\nimport module1 from './Module';\nexpoer default module1.test;\n\n// best\nimport { test } from './Module';\nexport default test;\n```\n\n### 相同路径导入\n```ts\n// bad\nimport foo from 'foo';\nimport { bar } from 'foo';\n\n// good\nimport foo, { bar } from 'foo';\n```\n\n### 导出 - 尽量使用一个导出利于维护\n```ts\n// bad\nexport function fun() {}\n\n// ok\nconst func = () => {}\nexport {\n  func\n}\n\n// good\nexport default function foo() {}\n```\n\n### `import`位于所有非导入语句上面\n`import`会被提升， 防止出错\n\n```ts\n// bad\nimport foo from 'foo';\nconst COUNT = 10;\nimport bar form 'bar';\n\n// good\nimport foo from 'foo';\nimport bar form 'bar';\n\nconst COUNT = 10;\n```\n\n## 迭代器\n> 使用高阶函数代替迭代器，避免`for-in`和`for-of`循环的使用\n\n- 纯函数，容易维护\n- `map()` `every()` `filter()` `find()` `findIndex()` `reducer()` `some()`\n- `Object.key()` `Object.values()` `Object.entries()` 对象生成迭代数组\n\n```ts\n// bad\nlet sum = 0;\nfor (let num of numbers) {\n    sum += num;\n}\n\nfor (let i = 0, const len = numbers.length; i < len; i++) { \n  arr.push(numbers[i] + 1); \n}\n\n// good\nnumbers.forEach((num) => {\n    sum += num;\n});\n\nnumbers.forEach((num) => {\n  arr.push(num + 1);\n});\n\n\n// best\nconst sum = numbers.reduce((total, num) => total + num, 0);\nconst arr = numbers.map(num => num + 1);\n```\n\n## 代码风格\n\n### 操作符\n```ts\n/* -- 判断 - start -- */\n// bad\nflag == true; // === 代替 === \nconst ans = (a > 1 || b > 2 || check()) ? doSomeThing() : doOther()\n\n// good\nconst a == 1;\nconst ans = (a > 1 || b > 2 || check()) \n              ? doSomeThing() \n              : doOther();\n\nflag === true;\n/* -- 判断 - end -- */\n\n\n/* -- 长判断 - start -- */\n// bad - 长判断\nif ((a >= 2 && b < 3) || checkSomething() || (number + getValue() === 6)) {} \n\n// good\nif (\n  (a >= 2 && b < 3)\n  && checkSomething()\n  && (number + getValue() === 6)\n) {}\n\n/* -- 长判断 - end -- */\n\n\n/* -- 混合操作符使用括号 - start -- */\n// bad\nconst foo = a && b < 0 || c > 0 || d + 1 === 0; // \nconst ans = a * 3 - b / 2;\n\n// good\nconst foo = (a && b < 0) || c > 0 || (d + 1 === 0);\nconst ans = (a * 3) - (b / 2);\n/* -- 混合操作符使用括号 - end -- */\n\n```\n\n### 空格\n> 使用两个空格作为缩进\n\n```ts\n\n// bad - 运算符左右两边加空格\nconst a=1;\nconst a= 1;\nconst b = a+1;\nconst obj = {a:1}; // 大括号左右两边空格 :右侧空格\nif ( cond ) {} // 小括号左右两边不加空格\n\nconst ans = a?1:0;\n\nfunction func(){};\nfunction func () {};\nconst func=() => {};\n\nconst a = 1;?  // 行末尾不加空格\n\nif() {}\nif (){}\n\nclass Dog{\n  getName(){\n    \n  }\n}\n\nswitch (cond) {\n    \n}\n\nimport {a} from 'sss';\n\n// good\nconst a = 1;\nconst b = a + 1;\nconst obj = { a: 1 };\nif (cond) {}\n\nconst a = a ? 1 : 0;\n\nfunction func() {};\nconst func = () => {};\n\nif () {}\n\nclass Dog {\n  getName() { // 左侧无空格\n    \n  }\n}\n\nswitch(cond) {\n    \n}\n\nimport { a } from 'sss';\n```\n\n### 空行\n- 不同逻辑代码段之间需要空行\n- 文件结尾加空行\n- 不要用空白行填充代码段\n\n```ts\nconst isEated = checkEated();\nif (isEated) {\n  \n}\n\ndoAnother();\n\ndoLasteThing();\n\n// bad\nfunction func() {\n  \n  console.log('kkk')\n  \n}\n\n// good\nfunction func() {\n  console.log('kkk')\n}\n```\n\n### 变量\n```ts\n// bad\nconst a = 1,  // 容易出现, ;错乱\n      b = 2,\n      c = 3;\n\nconst a = 1;\nlet flag = true;\nconst b = 2;\n\n// good\nconst a = 1;\nconst b = 2;\nconst c = 3;\n\nconst a = 1;\nconst b = 2;\nlet flag = true;\n```\n\n### 代码块\n```ts\n// bad\nif (cond)\n  return;\n\nif (cond) { return false; }\n\nif (cond) { //不一换行\n  \n} \nelse {\n  \n}\n\nfunction func() {\n  if (cond) {\n    return x;\n  } else {\n    return y;  // 不需要else\n  }\n}\n\nswitch(cond) {\n  case 1:\n    // 不加break需要额外写注释\n  case 2:\n    doSomething();\n    break;\n  // default不能缺少\n}\n\n// good\nif (cond) return;  // 除直接return 都需要加{} 并换行\nif (cond) {\n  return false;\n}\n\nif (cond) {\n\n} else {\n  \n}\n\nfunction func() {\n  if (cond) {\n    return x;\n  } \n  \n  return y;\n}\n\nswitch(cond) {\n  case 1:\n    check();\n    break;\n  case 2:\n    doSomething();\n    break;\n  defalut:\n    // 为空需要写注释\n}\n```\n\n## 链式调用\n```ts\n// bad\nconst ans = getValue().fist().second().third() 两个以上换行以.开头\n\n// good\nconst ans = getValue()\n  .fist()\n  .second()\n  .third()\n```\n\n## 简写代码\n```ts\n// bad\nconst a = check() ? doSomething() : null;\n\n// good\nconst a = check() && doSomething()\n```\n","tags":[],"folderPathname":"/font","data":{},"createdAt":"2020-08-07T02:52:18.377Z","updatedAt":"2020-08-07T02:52:34.127Z","trashed":false,"_id":"note:u8scwja5G","_rev":"4-57ccb6c9aec27ee104da7ce4640c0d13"}