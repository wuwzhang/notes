{"title":"第12期","content":"## 2021/01/22\n\n## 每日资讯\n### 1. 你不知道的`Proxy`\n\n`Proxy` 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）\n\n使用`Proxy`，你可以将一只猫伪装成一只老虎\n\n```js\n// target 你想包裹的原始对象\n// handler 用来定义怎么拦截原始对象\nconst proxy = new Proxy(target, handler);\n```\n![](https://user-gold-cdn.xitu.io/2020/3/23/171080fddf4dfe8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- 对比`Object.defineProperty`\n\n![](https://user-gold-cdn.xitu.io/2020/3/24/171085c728fc3797?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n**那`Proxy`有什么应用场景吗**\n#### 默认值/“零值”\n在`Go`语言中，有零值的概念，零值是特定于类型的隐式默认结构值\n\n```js\nconst withZeroValue = (target, zeroValue) => new Proxy(target, {\n  get: (obj, prop) => (prop in obj) ? obj[prop] : zeroValue\n})\n\nconst STATUS = {\n\t1: { label: 'success', color: 'green' },\n\t2: { label: 'warn', color: 'orange' },\n\t3: { label: 'error', color: 'red' }\n}\n\nconst status = withZeroValue(STATUS, { label: 'default', color: 'gray' })\n\nSTATUS[1].label // success\nSTATUS[4].label // ops! TypeError\nstatus[1].label // success\nstatus[4].label // default\n```\n#### 负索引数组\n`JS`中获取最后一个元素，写法既冗长又容易出错，实现一个类似`Python`使用`arr[-1]`获取最后一个元素的方法\n\n```js\nconst negativeArray = (els) => new Proxy(els, {\n  get: (target, propKey, receiver) => Reflect.get(target,\n    (+propKey < 0) ? String(target.length + +propKey) : propKey, receiver)\n});\n\n```\n\n#### 运算符重载\n`in`操作符用于检查指定的属性是否位于指定的对象或其原型链中\n\n```js\nconst range = (min, max) => new Proxy(Object.create(null), {\n  has: (_, prop) => (+prop >= min && +prop <= max)\n})\n\nconst X = 10.5\nconst nums = [1, 5, X, 50, 100]\n\nif (X in range(1, 100)) { // true\n  // ...\n}\n\nnums.filter(n => n in range(1, 10)) // [1, 5]\n```\n#### 实现只读\n```js\nconst NOPE = () => {\n  throw new Error(\"Can't modify read-only view\");\n}\n\nconst NOPE_HANDLER = {\n  set: NOPE,\n  defineProperty: NOPE,\n  deleteProperty: NOPE,\n  preventExtensions: NOPE,\n  setPrototypeOf: NOPE\n}\n\nconst readOnlyView = target =>\n  new Proxy(target, NOPE_HANDLER)\n```\n#### 缓存\n对于复杂的操作进行缓存\n```js\nconst numTarget = {\n\ttitle: 'a complex fn',\n\tbase: 10,\n\tget getNum() {\n\t\tconsole.log('balabala 一顿复杂操作')\n\t\treturn this.base * 2\n\t}\n}\n\nlet cache = {\n\tcurBase: null,\n\tcurValue: null,\n}\n\nconst handler = {\n\tget(target, prop) {\n\t\tif (prop === 'getNum') {\n\t\t\tconst value = cache.curBase !== target.base ? target[prop] : cache.curValue\n\t\t\t\n\t\t\tcache.curValue = value\n\t\t\tcache.curBase = target.base\n\t\t\t\n\t\t\treturn value\n\t\t}\n\t\t\n\t\treturn target[prop]\n\t}\n}\n\nconst cachedNum = new Proxy(numTarget, handler)\n\ncachedNum.getNum // 'balabala 一顿复杂操作' 20\ncachedNum.getNum // 20\ncachedNum.getNum // 20\n```\n#### 属性缓存\n对象上的所有属性在一段时间后都无法访问, 此处只实现了简易版，还可以扩展每个属性添加`tts`、访问次数等\n\n```js\nconst ephemeral = (target, ttl = 60) => {\n  const CREATED_AT = Date.now()\n  const isExpired = () => (Date.now() - CREATED_AT) > (ttl * 1000)\n  \n  return new Proxy(target, {\n    get: (obj, prop) => isExpired() ? undefined : Reflect.get(obj, prop)\n  })\n}\n\nlet bankAccount = ephemeral({\n  balance: 14.93\n}, 10)\n\nconsole.log(bankAccount.balance)    // 14.93\n\nsetTimeout(() => {\n  console.log(bankAccount.balance)  // undefined\n}, 10 * 1000)\n```\n#### 快照\n`Proxy`能追踪属性变化，维护历史记录\n\n```js\nconst createHistory = obj => {\n   let history = [JSON.parse(JSON.stringify(obj))];\n   const proxiedObject = new Proxy(obj, {\n     set: function(target, key, value) {\n       history.push({ ...target, [key]: value });\n       Reflect.set(target, key, value);\n     },\n   });\n   return [history, proxiedObject];\n };\n\nconst org = { k1: 1, k2: 'a' }\n\nconst [logs, handler] = createHistory(org)\n\nhandler.k1 = 2\nhandler.k2 = 'b'\n\nlogs \n// [{ k1: 1, k2: 'a' }, { k1: 2, k2: 'a' }, { k1: 2, k2: 'b' }]\n```\n#### 管道\n用过`RxJS`的同学肯定会对他的`pipe`印象深刻，而`ESMA`的最新提按中也出现了管道操作符`|>`, 而使用`Proxy`也能实现类似的功能\n\n```js\n// pipe(n).f1.f2...fn.done 链式调用值\n// 访问done返回数据\n\nconst pipe = v => {\n\tconst stack = []\n\tconst proxy = new Proxy({}, {\n\t\tget(target, prop) {\n\t\t\tif (target === 'done') {\n\t\t\t\treturn stack.reduce((u, fn) => fn(u), v)\n\t\t\t}\n\t\t\tstack.push(window[prop])\n\t\t\treturn proxy\n\t\t}\n\t})\n\t\n\treturn proxy\n}\n\nconst addOne = x => x + 1\nconst double = x => x * 2\n\npipe(2).addOne.double.done\n```\n\n### 相关文章\n- [MDN - Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n- [A practical guide to Javascript Proxy](https://blog.bitsrc.io/a-practical-guide-to-es6-proxy-229079c3c2f0)\n- [The Amazing Power of JavaScript Proxies](https://levelup.gitconnected.com/the-amazing-power-of-javascript-proxies-aa27c6d06bcb)\n- [Using javascript proxy](https://dev.to/rafi993/using-javascript-proxies-d0b)\n- [用 ES6 Proxy 能做哪些有意思的事情？](https://juejin.cn/post/6844904101218631694)\n\n\n#### 相关文章\n\n## 30 seconds of code\n### 目标\n判断是否为合法的`json`数据\n\n### 样例输出: \n```js\nisValidJSON('{\"name\":\"Adam\",\"age\":20}'); // true\nisValidJSON('{\"name\":\"Adam\",age:\"20\"}'); // false\nisValidJSON(null); // true\n```\n\n### 参考实现\n```js\nconst isValidJSON = str => {\n  try {\n    JSON.parse(str);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 每日一问\n> 以下代码的运行结果是？\n\n```js\nconst map = ['a', 'b', 'c'].map.bind([1, 2, 3])\nmap(el => console.log(el))\n```\n\n- A &nbsp;&nbsp;`1 2 3` \n- B &nbsp;&nbsp;`a b c`\n- C &nbsp;&nbsp;`error` \n- D &nbsp;&nbsp;`其他`\n\n## 每日二问\n> 当您单击该段落时，日志输出是什么？\n\n```js\n<div onclick=\"console.log('div')\">\n  <p onclick=\"console.log('p')\">\n    Click here!\n  </p>\n</div>\n```\n\n- A &nbsp;&nbsp;`p div` \n- B &nbsp;&nbsp;`div p`\n- C &nbsp;&nbsp;`p` \n- D &nbsp;&nbsp;`div`\n\n### 昨天的答案\n#### 第一题\n- C\n\n#### 第二题\n- C\n- 扩展运算符`（...args）`会返回实参组成的数组。而数组是对象，因此 `typeof args` 返回 `\"object\"`。","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-02-22T07:03:09.190Z","updatedAt":"2021-02-22T07:06:28.532Z","trashed":false,"_id":"note:D-9tJaeg1","_rev":"3-f63bafb11368a4a4f92ab332affface6"}