{"_id":"note:fyMjT4xK-","title":"curry","content":"## 柯里化（`curry`）\n> `curry`的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数\n\n```js\nvar add = function(x) {\n  return function(y) {\n    return x + y;\n  };\n};\n\nvar increment = add(1);\nvar addTen = add(10);\n\nincrement(2);\n// 3\n\naddTen(2);\n// 12\n```\n\n这里我们定义了一个`add`函数，它接受一个参数并返回一个新的函数。调用`add` 之后，返回的函数就通过闭包的方式记住了`add`的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的`curry`帮助函数（`helper function`）使这类函数的定义和调用更加容易\n\n我们来创建一些`curry`函数享受下\n```js\nvar curry = require('lodash').curry;\n\nvar match = curry(function(what, str) {\n  return str.match(what);\n});\n\nvar replace = curry(function(what, replacement, str) {\n  return str.replace(what, replacement);\n});\n\nvar filter = curry(function(f, ary) {\n  return ary.filter(f);\n});\n\nvar map = curry(function(f, ary) {\n  return ary.map(f);\n});\n```\n我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（`String， Array`）放到最后一个参数里。到使用它们的时候你就明白这样做的原因是什么了。\n\n```js\nmatch(/\\s+/g, \"hello world\");\n// [ ' ' ]\n\nmatch(/\\s+/g)(\"hello world\");\n// [ ' ' ]\n\nvar hasSpaces = match(/\\s+/g);\n// function(x) { return x.match(/\\s+/g) }\n\nhasSpaces(\"hello world\");\n// [ ' ' ]\n\nhasSpaces(\"spaceless\");\n// null\n\nfilter(hasSpaces, [\"tori_spelling\", \"tori amos\"]);\n// [\"tori amos\"]\n\nvar findSpaces = filter(hasSpaces);\n// function(xs) { return xs.filter(function(x) { return x.match(/\\s+/g) }) }\n\nfindSpaces([\"tori_spelling\", \"tori amos\"]);\n// [\"tori amos\"]\n\nvar noVowels = replace(/[aeiou]/ig);\n// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }\n\nvar censored = noVowels(\"*\");\n// function(x) { return x.replace(/[aeiou]/ig, \"*\") }\n\ncensored(\"Chocolate Rain\");\n// 'Ch*c*l*t* R**n'\n```\n这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。","tags":[],"folderPathname":"/font/函数式","data":{},"createdAt":"2021-04-07T02:21:12.792Z","updatedAt":"2021-04-07T02:30:01.994Z","trashed":false,"_rev":"mIbKiNHXq"}