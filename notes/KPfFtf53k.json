{"title":"前端代码质量","content":"前端代码质量\n==\n\n> 如何使前端代码变得可维护可读, 如何量化定义代码的复杂度\n\n## 现状\n- 团队代码风格不一致，无法进行整体质量把控\n- 没办法量化代码复杂度\n\n## 圈复杂度\n### 定义\n`圈复杂度`用来衡量一个模块判定结构的复杂程度，数量上表现为线性无关的路径条数，即合理的预防错误所需测试的最少路径条数。圈复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。\n\n### 衡量标准\n### 计算方法\n> 采用判定节点数$$+1$$\n\n- 判断\n  - `if - else`\n  - `switch - case`\n    - 一个`case`数量`+1`\n  - 三元\n- 循环\n  - `for`\n- 条件\n  - `&&` `||`\n\n```ts\nfunction getComplexity(value) {\n  let result = 1;\n    if (value < 0) {\n        result--;\n    }\n  \n    for (let i = 0; i < 10; i++) {\n        result += Math.random();\n    }\n  \n    switch (+result) {\n        case 1:\n            result += 20;\n            break;\n        case 2:\n            result += 30;\n            break;\n        default:\n            result += 10;\n            break;\n    }\n  \n    return result > 20 ? result : result;\n}\n\ncomplexity = 1(if) + 1(for) + 2(case) + 1(三目) + 1 = 6\n```\n\n### 点边计算\n$$M = E - N + 2P$$\n- `E`: 控制流图中边的数量\n- `N`: 控制流中点的数量\n- `P`: 独立组件数量\n\n## 降低圈复杂度\n### 抽象配置\n\n- 优化前\n```ts\nfunction doSomething(payload) {\n  if (payload.type === \"EAT\") {\n    eat(payload.value);\n  } else if (payload.type === \"WRITE\") {\n    write(payload.value);\n  } else if (payload.type === \"SING\") {\n    sing(payload.type);\n  }\n}\n\n// 圈复杂度 4\n```\n\n- 优化后\n```ts\nconst ACTIONS = {\n  \"EAT\": eat,\n  \"WRITE\": write,\n  \"SING\": sing\n};\n\nfunction doSomething(payload) {\n  ACTIONS[payload.type](payload.value);\n}\n\n// 圈复杂度 1\n```\n\n### 提炼函数\n> 一个功能函数只做一件事\n\n- 优化前\n```ts\nfunction doSomething(v, u) {\n  if (v < u) {\n    v = v + u;\n    u = v - u;\n    v = v - u;\n  } \n  \n  doOther(v, u);\n}\n```\n\n- 优化后\n```ts\nconst getOrdered(v, u) {\n  if (v < u) {\n    v = v + u;\n    u = v - u;\n    v = v - u;\n  }\n  \n  return [v, u];\n}\n\nfunction doSomething(v, u) {  \n  ([v, u] = getOrdered(v, u))\n  \n  doOther(v, u);\n}\n```\n\n### 判断条件简化和提取\n> 重判断提取使用`Array.includes()`\n\n- 优化前\n```ts\nfunction check(name) {\n  if (name === \"wuw\" || name === \"polm\") {\n    console.log(\"good\");\n  }\n}\n```\n\n- 优化后\n```ts\nconst NAMES = [\"wuw\", \"polm\"];\n\nfunction checkout(name) {\n  if (NAMES.includes(name)) {\n    console.log(\"good\")\n  }\n}\n```\n\n### 使用`return`和`break`代替标记位\n- 优化前\n```ts\nfunction doSomething() {\n  \n  let flag = false;\n  for (let i = 0, len = arr.length; i < len; i++) {\n    if (arr[i].isNew) {\n      flag = false;\n    }    \n  }\n  \n  !flag && doSomething()\n}\n\n```\n","tags":[],"folderPathname":"/font","data":{},"createdAt":"2020-08-07T02:52:05.737Z","updatedAt":"2020-08-07T02:52:12.614Z","trashed":false,"_id":"note:KPfFtf53k","_rev":"2-492d52131342d95461e540fa73174c59"}