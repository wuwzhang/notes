{"_id":"note:TjvcewzVe","title":"第28期","content":"## 2021/03/24\n## 每周资讯 - 第`28`期\n### 1. 图解`HTTP`缓存\n#### 什么是`HTTP`缓存\n\n`HTTP`缓存可以说是`HTTP`性能优化中简单高效的一种优化方式了，缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当`web`缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。\n\n常见的`http`缓存只能缓存`get`请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指`GET`请求。\n\n#### 用户刷新/访问行为的手段分成三类\n- 在`URI`输入栏中输入然后回车/通过书签访问\n- `F5`/点击工具栏中的刷新按钮/右键菜单重新加载\n- `Ctl+F5` （完全不使用HTTP缓存）\n\n不同的刷新手段，会导致浏览器使用不同的缓存策略\n\n`HTTP`缓存主要是通过请求和响应报文头中的对应`Header`信息，来控制缓存的策略。\n\n响应头中相关字段为`Expires`、`Cache-Control`、`Last-Modified`、`Etag`。\n\n#### `HTTP`缓存分类\n- 根据是否需要**重新向服务器发起请求**来分类\n  - 强制缓存: 强制缓存如果生效，不需要再和服务器发生交互\n  - 协商缓存: 协商缓存不管是否生效，都需要与服务端发生交互\n- 根据是否可以被**单个或者多个用户**使用来分类\n  - 私有缓存\n  - 共享缓存\n\n强制缓存和协商缓存的一些对比:\n\n![](https://upload-images.jianshu.io/upload_images/4845448-ab0e961921da5694?imageMogr2/auto-orient/strip|imageView2/2/w/690/format/webp)\n\n假设浏览器有一个缓存数据库用于本地缓存，先看看浏览器请求资源的情况：\n\n![](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141639213-1923993391.png)\n\n##### 强缓存\n强制缓存在缓存数据未失效的情况下（即`Cache-Control`的`max-age`没有过期或者`Expires`的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。\n\n在缓存数据时，仅基于强制缓存，请求数据的流程如下:\n![](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)\n\n强制缓存生效时，`HTTP`状态码是`200`。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。在`Chrome` 中，强缓存又分为`Disk Cache`（存放在硬盘中）和`Memory Cache`（存放在内存中），存放的位置是由浏览器控制的。\n\n是否强缓存由`Expires`、`Cache-Control` 和 `Pragma` 3 个`Header` 属性共同来控制。\n\n![](https://upload-images.jianshu.io/upload_images/4845448-217723260f75ed90?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)\n\n在`HTTP 1.1`的版本，`Expires`被`Cache-Control`替代\n\n在`Chrome`浏览器中返回的`200`状态会有两种情况：\n- from memory cache\n  - 从内存中获取/一般缓存更新频率较高的js、图片、字体等资源\n- from disk cache\n  - 从磁盘中获取/一般缓存更新频率较低的js、css等资源\n\n这两种情况是`Chrome`自身的一种缓存策略，这也是为什么`Chrome`浏览器响应的快的原因。其他浏览返回的是已缓存状态，没有标识是从哪获取的缓存。\n\nChrome:\n![](https://upload-images.jianshu.io/upload_images/4845448-1cff8751a782e4c7?imageMogr2/auto-orient/strip|imageView2/2/w/570/format/webp)\n\nFirefox:\n![](https://upload-images.jianshu.io/upload_images/4845448-f0dd6442c2147820?imageMogr2/auto-orient/strip|imageView2/2/w/765/format/webp)\n\n```js\nconst express = require('express');\nconst app = express();\nvar options = { \n  etag: false, // 禁用协商缓存\n  lastModified: false, // 禁用协商缓存\n  setHeaders: (res, path, stat) => {\n    res.set('Cache-Control', 'max-age=10'); // 强缓存超时时间为10秒\n  },\n};\napp.use(express.static((__dirname + '/public'), options));\napp.listen(3000);\n\n```\n第一次加载，页面会向服务器请求数据，并在`Response Header`中添加`Cache-Control`，过期时间为`10`秒\n![](image-kmmrheru.png)\n\n第二次加载，`Date`头属性未更新，可以看到浏览器直接使用了强缓存，实际没有发送请求。\n![](image-kmmri07y.png)\n过了`10`秒的超时时间之后，再次请求资源：\n![](image-kmmrjaq8.png)\n\n不同的访问/刷新手段，会使浏览器使用不同的缓存策略，要让浏览器走强制缓存对请求方式有一个要求: 在`URI`输入栏中输入然后回车/通过书签访问\n\n##### 协商缓存\n当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存(属性设置为`no-cache`)，并且在请求头中设置了 `If-Modified-Since`或者`If-None-Match`的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回`304`状态，加载浏览器缓存，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。\n\n![](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)\n\n跟协商缓存相关的`header`头属性有（`ETag/If-Not-Match` 、`Last-Modified/If-Modified-Since`）请求头和响应头需要成对出现:\n![](https://upload-images.jianshu.io/upload_images/4845448-a22cef109d00aa79?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp)\n\n协商缓存的执行流程是这样的：\n- 当浏览器**第一次**向服务器发送请求时，会在响应头中返回协商缓存的头属性：`ETag`和`Last-Modified`\n  - `ETag`返回的是一个`hash`值\n  - `Last-Modified`返回的是`GMT`格式的最后修改时间。\n- 浏览器在**第二次**发送请求的时候，会在请求头中带上与`ETag`对应的`If-Not-Match`\n  - `ETag`就是响应头中返回的`ETag`的值\n  - `Last-Modified`对应的`If-Modified-Since`。\n- 服务器在接收到这两个参数后会做比\n  - 如果返回的是`304`状态码，则说明请求的资源没有修改，浏览器可以直接在缓存中取数据\n  - 否则，服务器会直接返回数据。\n\n```js\nconst express = require('express');\nconst app = express();\nvar options = { \n  etag: true, // 开启协商缓存\n  lastModified: true, // 开启协商缓存\n  setHeaders: (res, path, stat) => {\n    res.set({\n      'Cache-Control': 'max-age=00', // 浏览器不走强缓存\n      'Pragma': 'no-cache', // 浏览器不走强缓存\n    });\n  },\n};\napp.use(express.static((__dirname + '/public'), options));\napp.listen(3001);\n\n```\n第一次请求资源:\n![](https://static001.geekbang.org/infoq/7d/7d333f4797e6147422624af73432347d.webp)\n\n第二次请求资源，服务端根据请求头中的`If-Modified-Since`和`If-None-Match`验证文件是否修改。\n![](https://static001.geekbang.org/infoq/64/6494554dd1a2877bae6288cca3934921.webp)\n\n再来验证一下`ETag`在强校验的情况下，只增加一行空格，`hash`值如何变化，在代码中，采用的是对文件进行`MD5`加密来计算其`hash`值。\n\n**注**：只是为了演示用，实际计算不是通过`MD5`加密的，`Apache`默认通过`FileEtag`中`FileEtag INode Mtime Size`的配置自动生成`ETag`，用户可以通过自定义的方式来修改文件生成`ETag`的方式。\n\n为了保证`lastModified`不影响缓存，把通过`Last-Modified/If-Modified-Since`请求头删除了，源码如下：\n\n```js\nconst express = require('express');\nconst CryptoJS = require('crypto-js/crypto-js');\nconst fs = require('fs');\nconst app = express();\nvar options = { \n  etag: true, // 只通过Etag来判断\n  lastModified: false, // 关闭另一种协商缓存\n  setHeaders: (res, path, stat) => {\n    const data = fs.readFileSync(path, 'utf-8'); // 读取文件\n    const hash = CryptoJS.MD5((JSON.stringify(data))); // MD5加密\n    res.set({\n      'Cache-Control': 'max-age=00', // 浏览器不走强缓存\n      'Pragma': 'no-cache', // 浏览器不走强缓存\n      'ETag': hash, // 手动设置Etag值为MD5加密后的hash值\n    });\n  },\n};\napp.use(express.static((__dirname + '/public'), options));\napp.listen(4000); // 使用新端口号，否则上面验证的协商缓存会一直存在\n\n```\n第一次和第二次请求如下：\n![](https://static001.geekbang.org/infoq/a2/a2a127648387b91ed953f7e0af821d1d.webp)\n![](https://static001.geekbang.org/infoq/76/76c8d4f8059b5c3cc3fbf84e48495325.webp)\n\n然后修改了`test.js` ，增加一个空格后再删除一个空格，保持文件内容不变，但文件的修改时间改变，发起第三次请求，由于我生成`ETag`的方式是通过对文件内容进行 MD5 加密生成，所以虽然修改时间变化了，但请求依然返回了`304`，读取浏览器缓存。\n![](https://static001.geekbang.org/infoq/04/04826d47fd951a7c852608c3bdcce519.webp)\n\n`ETag/If-Not-Match`是在`HTTP/1.1`出现的，主要解决了`Last-Modified/If-Modified-Since`所解决不了的问题：\n\n- `Last-Modified`标注的最后修改只能精确到秒级，如果某些文件在`1`秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\n- 如果某些文件被修改了，但是内容并没有任何变化，而`Last-Modified`却改变了，导致文件没法使用缓存\n- 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\n\n\n##### 整体流程图:\n![](https://static001.geekbang.org/infoq/f4/f4c971ebefa670b4e4d22d05d2a4e535.webp)\n\n##### 私有缓存（浏览器级缓存）\n私有缓存只能用于单独的用户：`Cache-Control: Private`\n\n##### 共享缓存（代理级缓存）\n共享缓存可以被多个用户使用: `Cache-Control: Public`\n\n#### 为什么要使用HTTP缓存 ？\n1. 减少了冗余的数据传输，节省了网费。\n2. 缓解了服务器的压力， 大大提高了网站的性能\n3. 加快了客户端加载网页的速度\n\n#### HTTP缓存的几个注意点\n1. 强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。决解的办法有：在修改后的资源加上随机数,确保不会从缓存中取。\n\n例如：\nhttp://www.kimshare.club/kim/common.css?v=22324432\nhttp://www.kimshare.club/kim/common.2312331.css\n\n2. 尽量减少`304`的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。\n\n3. 在`Firefox`浏览器下，使用`Cache-Control: no-cache`是不生效的，其识别的是`no-store`。这样能达到其他浏览器使用`Cache-Control: no-cache`的效果。所以为了兼容`Firefox`浏览器，经常会写成`Cache-Control: no-cache，nostore`。\n\n#### 相关文章\n- [图解 HTTP 缓存](https://www.infoq.cn/article/AIwqlgtlk2efT5Yi7doY)\n- [从未如此简单：5分钟搞懂 HTTP 缓存机制](https://cloud.tencent.com/developer/news/588770)\n- [一文读懂http缓存（超详细）](https://www.jianshu.com/p/227cee9c8d15)\n\n### 2. `prism-react-renderer`: `Prism`语法高亮`React`组件 \n如果你用过`PrismJS`，你一定会爱上这个库，它为你提供了`Prism`语法高亮。\n![](image-kmm1li14.png)\n\n#### 相关文章\n- [prism-react-renderer - github](https://github.com/FormidableLabs/prism-react-renderer)\n- [demo with styled-components](https://codesandbox.io/s/prism-react-renderer-example-u6vhk?file=/src/WithLineNumbers.js)\n\n## 30 seconds of code\n### 目标\n检查代码是否在浏览器或服务器上运行。\n\n### 样例输出: \n```js\nconst SSRChecker = props => {\n  let { isBrowser, isServer } = useSSR();\n\n  return <p>{isBrowser ? 'Running on browser' : 'Running on server'}</p>;\n};\n\nReactDOM.render(<SSRChecker />, document.getElementById('root'));\n\n```\n### 参考实现\n```jsx\nconst isDOMavailable = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\nconst useSSR = () => {\n  const [inBrowser, setInBrowser] = React.useState(isDOMavailable);\n\n  React.useEffect(() => {\n    setInBrowser(isDOMavailable);\n    return () => {\n      setInBrowser(false);\n    };\n  }, []);\n\n  const useSSRObject = React.useMemo(\n    () => ({\n      isBrowser: inBrowser,\n      isServer: !inBrowser,\n      canUseWorkers: typeof Worker !== 'undefined',\n      canUseEventListeners: inBrowser && !!window.addEventListener,\n      canUseViewport: inBrowser && !!window.screen\n    }),\n    [inBrowser]\n  );\n\n  return React.useMemo(\n    () => Object.assign(Object.values(useSSRObject), useSSRObject),\n    [inBrowser]\n  );\n};\n\n```\n## 每日一问\n> 以下代码的运行结果为\n\n\n```js\n var val = 'smtg';\n console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');\n```\n\n\n## 每日二问\n> 以下代码的运行结果为\n\n```js\nNumber.MIN_VALUE > 0\n```\n\n### 上期的答案\n#### 第一题\n```js\nArray.isArray(Array.prototype)\n```\n- A、true\n- B、false\n- C、error\n- D、other\n\n> 答案A、true，`Array.prototype`是一个数组\n     数组的原型是数组，对象的原型是对象，函数的原型是函数\n\n#### 第二题\n> 以下代码的运行结果为\n\n```js\n2 == [[[2]]]\n```\n\n- A、 true\n- B、 false\n- C、 undefined\n- D、 other\n\n> 答案A、true, 值和引用类型比较,把引用类型转换成值类型\n\n[更多巩固](https://stackoverflow.com/questions/7202157/why-does-return-the-string-10/7202287#7202287)\n\n","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-03-18T06:14:14.159Z","updatedAt":"2021-03-24T01:24:14.109Z","trashed":false,"_rev":"Icht5ElAW"}