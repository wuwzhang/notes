{"_id":"note:KoX1k1ssn","title":"第70期","content":"## 2021/08/20\n## 每周资讯 - 第`70`期\n### 1. Axios中的参数为啥没被完全编码\n#### 起因\n在一次需求开发自测中遇到一个问题，一个接口的cateId3List参数中有未编码中括号（'['、']'），是url特殊字符，但在发这个Get请求时参数未完全被编码，在测试环境会导致服务端返回400错误，线上环境会概率性的400 Bad Request（和nginx层无关）。\n\n![](https://img-blog.csdnimg.cn/img_convert/877395d23ec9b1e8b7ab5a8e8c3291e6.png)\n\n_ps.该项目网络请求使用的是axios，这个接口在发出时没做过多的处理（可以理解成和用原生的axios发出请求是一样的）；下面都是以axios.get的方式为例来探讨下这个问题（axios版本0.19.2）。_\n\n#### 问题定位\n当时为了不阻塞测试流程，就先让QA通过在fiddler配置规则绕过了这个问题，使用的是fiddler自带的rewrite功能。\n\n![](https://img-blog.csdnimg.cn/img_convert/a38f1d90ef6f792c0938a3f01a707d84.png)\n\n这里rewrite做的事就是把请求参数的[、]给替成编码后的。\n\n根据以往使用axios的经验，我们在发请求时传入的参数明明是不需要主动预编码的，这里为什么会出问题呀！使用时，我们会像下面例子这样：\n\n```js\nconst axios = require('axios');\nconst argString = '你好';\naxios.get('/zzopen/sellbook/searchDefaultWord', {\n  params: {\n    arg: argString\n  }\n}).then(function (response) {\n  console.log(response);\n})\n```\n通过抓包发现发出去的请求，你好 确实已经被编码成 %E4%BD%A0%E5%A5%BD，我们并没有手动的去编码，这一切看起来都是理所当然的。\n\n![](https://img-blog.csdnimg.cn/img_convert/fa68847884b5e3d6768ddcb157043a7d.png)\n\n接下来，我们把上面请求的代码修改成这样：\n\n```js\nconst axios = require('axios');\nconst argString = JSON.stringify([\"你\", \"好\"]);//\"[\"你\",\"好\"]\"\naxios.get('/zzopen/sellbook/searchDefaultWord', {\n  params: {\n    arg: argString\n  }\n}).then(function (response) {\n  console.log(response);\n})\n```\n这时再看下发出去的请求：\n\n![](https://img-blog.csdnimg.cn/img_convert/52a3aa1ceaceb4467dbb21ce05434ff7.png)\n\n抓包发现和我们预想的不太一样，原本认为[\"你\", \"好\"]应该编码成 %5B%22%E4%BD%A0%22%2C%22%E5%A5%BD%22%5D ，而实际上却是 [%22%E4%BD%A0%22,%22%E5%A5%BD%22]，这不符合我们的预期呀，只编码了[、]中间的内容，而中括号直接忽略了。想不明白呀，我们只能带着疑问去看看[axios源码](https://github.com/axios/axios)搞啥子了，功夫不负有心人，最终找到了关键性的代码buildURL.js，这里有关键性的代码：\n\n![](https://img-blog.csdnimg.cn/img_convert/bf70b59720c39a02e01e6ec886860779.png)\n\n我们继续跟进去看下encode方法的实现：\n\n![](https://img-blog.csdnimg.cn/img_convert/7e0a9dcb7ab264353543162995e2d19e.png)\n\n发现在这里会组装Get请求参数，外面传入的参数会在这里构造后拼接到url后，但是特殊的点就在这里：进行 encodeURIComponent 后，会在把部分encode后的参数的通过正则的方式在还原成了原本的字符了，What  ？？？\n\n#### 为什么\n问题看到这里从源码上也看不出来啥子了。又看了下提交历史，这块代码的修改首次提交时间2015年7月，看来是个历史悠久的问题。\n![](https://img-blog.csdnimg.cn/img_convert/651db45a7c7e8a218b57a75b2f7e0c69.png)\n\n但是为什么要加上这些代码呢，提交注释里只有don’t escape square brackets。当问题不知如何下手时，就只能去怀疑猜测了。然后就想着是不是URL规范就这么规定的????，然后就去看看URI（URL是URI的子集）的规范。这里就要提到rfc3986（主要原因在这个规范里），内容比较多感兴趣的可以到[这里查看](https://tools.ietf.org/html/rfc3986)，网上也有中文的 版的，大家感兴可以去看看。在规范中提到URL只允许包含四种大类的字符（也称非保留字符）：\n\n1. 英文字母（a-zA-Z）\n2. 数字（0-9）\n3. -_.~ 4个特殊字符\n4. 保留字符，RFC3986中指定了保留字符（英文字符）为： ! * ' ( ) ; : @ & = + $ , / ? # [ ]\n\n看到这里心里大概就个底了，原来[、]是可以不用在进行编码的（编码了也没啥问题）。\n\n再说说这个规范谁制定的，ietf，主要工作是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。说白了互联网标准就是这货制定的，用前端的JS视角比喻的话，就有点类似TC39，rfcxxx类似ECMAScript标准。这个规范早在2005年就制定了，为啥到现在还没有完全普及，说到这就和前端的场景更像了，虽然都是标准，但是别人可以不实现，晚实现（eg.浏览器对各语法的支持情况）。到这里编码的问题，我们了解了大致的来龙去脉。\n\n不过，还有疑惑未解，上面还提到了概率性的400 Bad Reques，这个由于啥原因呢，想要得到答案只能从后端/运维下手了，后面和运维同学沟通了解到知道，运维 只对个别机器的tomcat做过临时的兼容配置，到这里答案就明了了。\n\n如果想通过后端的方式来处理的话，就是修改Tomcat提供的配置字段（conf/catalina.properties），让其兼容需要的字符：\n\n![](https://img-blog.csdnimg.cn/img_convert/0023a9e09f73a3b119d0a1c4ac7a1769.png)\n\n#### 我们要怎么改\n这里撇开服务端去修改Tomcat这类的配置，来谈谈前端有哪些解决方法。\n\n##### 修改请求为post\n\n当时遇到这个问题时，没时间过多的去追究原因，就改用post请求来规避这个问题，现在回看下，post方式是规避了axios对参数的encode。\n\n##### 修改axios源码\n\n关于这一点，在GitHub上有人提了Pull request #2563 提了，但是最终被关闭未能合并到主分支上。如果要修改的话，可以参考这个 commit id的写法：\n\n![](https://img-blog.csdnimg.cn/img_convert/19a5342164c1f81d1beec106da3c0187.png)\n\n##### 参数直接拼接URL上\n\n从axios源码上看，我们也可以预先把请求参数拼接到URL上，然后axios就不会再对处理，像这样：\n\n```js\nconst axios = require('axios');\nconst argString = JSON.stringify([\"你\", \"好\"]);//\"[\"你\",\"好\"]\"\naxios.post('/zzopen/sellbook/searchDefaultWord?arg=' + encodeURIComponent(argString))\n  .then(function (response) {\n  console.log(response);\n})\n```\n可以看到参数正常编码了\n\n![](https://img-blog.csdnimg.cn/img_convert/082c753391c9af2b5a62b5a97239c4d3.png)\n\n##### 使用paramsSerializer处理\n\naxios给出的建议如果参数不满足默认的编码方式的话，可以通过paramsSerializer进行自定义编码(序列化)，这种方式还是值得推荐的，也能够一劳永逸。\n\n```js\nconst axios = require('axios');\naxios.defaults.paramsSerializer = (params) => {\n  return Object.keys(params).filter(it => {\n    return params.hasOwnProperty(it)\n  }).reduce((pre, curr) => {\n    return params[curr] ? (pre ? pre + '&' : '') + curr + '=' + encodeURIComponent(params[curr]) : pre;\n  }, '');\n};\n//正常请求\nconst argString = JSON.stringify([\"你\", \"好\"]);//\"[\"你\",\"好\"]\"\naxios.get('/zzopen/sellbook/searchDefaultWord', {\n  params: {\n    arg: argString,\n  }\n}).then(function (response) {\n  console.log(response);\n})\n```\n\n#### 最后\n这个问题，可简单可复杂。往简单的说，我们可以换成post请求完事，仿佛没发生过；往复杂方向去看，需要我们一路往下去深究，不停的问为什么，不停的找答案；回头再看这个过程，其实就是一个自我学习提升的过程。\n\n#### 相关文章\n- [Axios中的参数为啥没被完全编码](https://blog.csdn.net/P6P7qsW6ua47A2Sb/article/details/119465740)\n\n### 2. [Jamstack，下一代Web建站技术栈？](https://zhuanlan.zhihu.com/p/281085404)\n\n#### Jamstack是什么？\nJamstack 指的是一套用于构建现代网站的技术栈，可能过去的一些文章通常会把它们理解为 JavaScript、APIs、Markup，但其实现在这个概念已经被扩大了，Jamstack 的官网上将它的核心概念归纳为 Pre-rendering、Enhancing with JavaScript、Supercharging with services。\n\n#### 相关文章\n- [Jamstack，下一代Web建站技术栈？](https://zhuanlan.zhihu.com/p/281085404)\n\n## 30 seconds of code\n### 目标\ncookie解析\n\n### 样例输出\n```js\nparseCookie(document.cookie)\n// {_octo: \"GH1.1.167315027.1607234551\", tz: \"Asia/Shanghai\"}\n```\n### 参考实现\n```js\nconst parseCookie = (str) =>\n  str\n    .split(';')\n    .map((v) => v.split('='))\n    .reduce((acc, v) => {\n      acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());\n      return acc;\n    }, {});\n```\n\n### 每日一问\n>  redux 为什么要把 reducer 设计成纯函数\n\n### 每日二问\n> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n说明:\n- 必须在原数组上操作，不能拷贝额外的数组。\n- 尽量减少操作次数。\n\n示例\n```\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n## 上期答案\n### 每日一问\n> React setState 笔试题，下面的代码输出什么？\n\n```js    \nclass Example extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      val: 0\n    };\n  }\n  \n  componentDidMount() {\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);    // 第 1 次 log\n\n    this.setState({val: this.state.val + 1});\n    console.log(this.state.val);    // 第 2 次 log\n\n    setTimeout(() => {\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);  // 第 3 次 log\n\n      this.setState({val: this.state.val + 1});\n      console.log(this.state.val);  // 第 4 次 log\n    }, 0);\n  }\n\n  render() {\n    return null;\n  }\n};\n```\n\n1. 第一次和第二次都是在 react 自身生命周期内，触发时 isBatchingUpdates 为 true，所以并不会直接执行更新 state，而是加入了 dirtyComponents，所以打印时获取的都是更新前的状态 0。\n\n2. 两次 setState 时，获取到 this.state.val 都是 0，所以执行时都是将 0 设置成 1，在 react 内部会被合并掉，只执行一次。设置完成后 state.val 值为 1。\n\n3. setTimeout 中的代码，触发时 isBatchingUpdates 为 false，所以能够直接进行更新，所以连着输出 2，3。\n\n> 输出： 0 0 2 3\n\n### 每日二问\n> 介绍下 BFC 及其应用\n\nBFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。\n创建 BFC 的方式有：\n- html 根元素\n- float的值不是none\n- position的值不是static或者relative\n- overflow 不为 visiable\n- display的值是inline-block、table-cell、flex、table-caption或者inline-flex\n\nBFC 主要的作用是：\n- 清除浮动\n- 自适应两栏布局\n- 防止同一 BFC 容器中的相邻元素间的外边距重叠问题","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-08-19T11:14:36.205Z","updatedAt":"2021-08-20T01:35:28.237Z","trashed":false,"_rev":"Jj0FKe7k9"}