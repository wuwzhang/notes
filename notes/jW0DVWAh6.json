{"_id":"note:jW0DVWAh6","title":"第45期","content":"## 2021/05/25\n## 每周资讯 - 第`45`期\n### 1. [React 17中的新JSX增强功能](https://mp.weixin.qq.com/s/Pg1V3RtIeA4WAEDnOxDrgA)\n\n本文主要介绍React 17中JSX的新特性以及你为什么要关注它。\n\nReact 17的发布是独一无二的。几乎没有任何你会注意到的新功能。然而，你可以找到几个对React核心影响很大的改进。在这些改进中，JJSX的变化是非常明显的。\n\n本文将讨论JSX的改进，它们背后的动机，以及每个开发者在升级到React 17之前应该知道的事情。\n\n首先，最重要的是，让我们看看你将从外部体验到的变化。\n\n#### 对开发者来说，可见的变化\n对React 17的肤浅研究肯定会让你印象不深。真正令人兴奋的东西不是新功能，而是在React的编译方式。\n\n为了更好地理解这些，让我们看一下使用旧版React的组件中的JSX的编译代码。\n\n![](https://upload-images.jianshu.io/upload_images/25473367-ff724059a67a721e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\n你可能会注意到，编译后的版本使用React.createElement，其中React的依赖性应该在范围内可用。这就是为什么你需要在每个组件中首先导入React。\n\n现在让我们来看看它在React 17中是如何工作的。\n\n有了React 17，**你就不需要为JSX导入React了**。\n\n我希望这能提供一个线索，即编译后的版本不需要React的导入。\n\n正如你在下图中看到的，React 17编译器从`react/jsx-runtime`导入了一个新的依赖项，它处理JSX转换。\n\n![](https://upload-images.jianshu.io/upload_images/25473367-b3af59e7237f5d52.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)\n\n因此，作为开发者，一旦你升级到React 17，你可以从你的组件的代码中删除React导入，如果它只是为了JSX而存在。\n\n**但这是唯一的变化吗，有关系吗？**\n\n正如你已经注意到的，从外面看效果似乎无关紧要。\n\n重要的是要明白，当你的代码库中有更多的React组件时，整体效果会显现出来\n\n为了更好地理解这种影响，让我们看看为什么取消与React.createElement的依赖关系对JSX很重要。\n\n#### 删除createElement的好处\n首先做个总结的话，有几个点:\n- 减少捆绑文件的大小\n- 减少动态属性查询\n- Props、Args和KeyRef相关的改进\n\n##### 减少捆绑文件的大小\n首先，可以想到的一点是：减少捆绑文件的大小。\n\n随着React导入的删除，你的编译捆绑输出的大小将变得稍微小一些。我希望这一点变得很明显，因为我们需要在编译器将其替换为React中的子模块的每个组件中删除React导入，如下所示：\n\n```jsx\nimport {jsx as _jsx} from 'react/jsx-runtime';\n```\n\n##### 减少动态属性查询\n由于React 17不再为JSX使用React.createElement，因此消除了对动态属性查找的需要。正如前面所讨论的，你可以在前端代码库的编译版本中找到这个。\n\n然而，这里的性能改进是非常小的，在这里你几乎不会注意到差异 这是因为现代的JavaScript引擎主要是针对动态属性查询进行优化的。\n\n##### Props、Args和KeyRef相关的改进\n好吧，我只是想告诉你，这些改进存在于React 17中。然而，这些改进太过技术性，无法详述。如果你有兴趣，你可以在Motivation部分的create-element-changes中阅读它们。\n\n#### 需要用React17吗\n如果你在JSX之外创建动态元素，你仍然需要React.createElement方法。\n\n如果你需要在你的代码中手动创建元素，你应该继续使用React.createElement。\n\n此外，你可能会想，我们不是还在使用react/jsx-runtime来替代React 17的React.createElement的JSX吗，这些问题在那里得到了解决吗？简而言之，是的!\n\n当我们看新的react/jsx-runtime时，它带来了一些设计上的变化，以避免React.createElement方法中出现的瓶颈问题。\n\n其中一些变化的引入是为了在未来的架构中有所发展。\n\n你可以在详细设计部分下的同一链接[create-element-changes](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation)中阅读这些内容\n\n#### 你还应该知道什么？\n嗯，这不是别的，而是废弃通知。\n\n在React 17 JSX的变化中，有几个通知是你应该注意的。\n\n##### 废除 \"模块模式 \"组件\n```jsx\nconst Foo = (props) => {\n  return {\n    onClick() {\n      //...\n    }\n    render() {\n      return <div onClick={this.onClick.bind(this)} />;\n    }\n  }\n};\n```\n\n然而，通过做下面提到的两个改变，升级会更容易\n- 使用函数表达式而不是箭头函数。\n- 添加一个带有isReactComponent的原型，告诉React区分类和函数组件\n\n结果看起来如下\n```jsx\n\nfunction Foo(props) {\n  return {\n    onClick() {\n      //...\n    }\n    render() {\n      return <div onClick={this.onClick.bind(this)} />;\n    }\n  }\n};\nFoo.prototype = { isReactComponent: true};\n```\n\n同样，也会有以下的废弃通知。\n- 废弃函数组件上的defaultProps。\n- 废弃对象中的spreading key。\n- 废弃字符串引用（并删除生产模式_所有者字段）。\n\n你可以在详细设计部分的同一个链接[create-element-changes](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation)中读到它们\n\n然而，这些警告并不妨碍你迁移到React 17。在下一个主要版本之前，你也有时间来升级它们。\n\n#### 总结\nJSX变换的好消息是，它是向后兼容的，升级到React 17的变化很小。\n\n但我觉得影响可能会更好，因为目前的改进在现实世界中几乎看不到。\n\n然而，同样重要的是要明白，这些改进中的大部分将有助于加速未来的发布。因此，升级到React 17将使你的代码库面向未来。而且你不需要提醒自己在JSX文件中保留React导入。\n\n此外，如果你从旧版本升级，值得参考废止通知，以避免将来出现任何麻烦。\n#### 相关文章\n- [React 17中的新JSX增强功能](https://mp.weixin.qq.com/s/Pg1V3RtIeA4WAEDnOxDrgA)\n- [create-element-changes](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation)\n\n### 2. [W3C工作重点：网络与通信](https://mp.weixin.qq.com/s/Gg5VThP3cU75h2QPY3labw)\nWeb 是移动的开放平台。长期以来，电信服务提供商和网络设备提供商一直是 Web 技术部署中的关键角色。随着 Web 平台的成熟，它带来了越来越丰富的功能，进而将现有服务扩展到新用户和设备，并提出新的创新服务\n#### 相关文章\n- [W3C工作重点：网络与通信](https://mp.weixin.qq.com/s/Gg5VThP3cU75h2QPY3labw)\n\n## 30 seconds of code\n### 目标\n根据给定的顺序，重新给数组的排列\n\n### 样例输出: \n```js\nvar rearged = rearg(\n  function(a, b, c) {\n    return [a, b, c];\n  },\n  [2, 0, 1]\n);\nrearged('b', 'c', 'a'); // ['a', 'b', 'c']\n```\n### 参考实现\n```js\nconst rearg = (fn, indexes) => (...args) => fn(...indexes.map(i => args[i]));\n```\n## 每日一问\n> 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景\n\n## 每日二问\n> 模拟 localStorage 时如何实现过期时间功能\n\n### 上期的答案\n## 每日一问\n> 以下代码的运行结果为\n\n```js\nlet a = 0;\nconst obj = {\n    a: 1,\n    b: function() {\n    console.log(this.a);\n    }\n}\nconst obj1 = {\n    a: 2\n}\nconst fun = obj.b;\nfun(); \nfun.apply(obj); \nfun.bind(obj1).apply(obj); \nconst fun1 = fun.bind(obj1);\nnew fun(); \n```\n\n- A: 0 1 2 2\n- B: 0 1 2 undefined\n- C: undefined 1 2 undefined\n- D: undefined 1 2 2\n\n正确答案: C\n## 每日二问\n> 以下代码的运行结果为\n\n```js    \nconst arr = [];\nconst testObj = {};\nconsole.log(arr === \"\");\nconsole.log(arr == \"\");\narr.toString = () => 1;\nconsole.log(arr === 1);\nconsole.log(arr == 1);\narr.valueOf = () => 2;\nconsole.log(arr == 2);\narr.valueOf = () => testObj;\nconsole.log(arr == testObj);\n```\n\n- A: false true false true true false\n- B：false false false true false false\n- C: false true false false true true\n- D: false true true true true false\n\n正确答案: A","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-05-20T10:18:22.946Z","updatedAt":"2021-05-25T10:12:35.473Z","trashed":false,"_rev":"-5e7tZgm_"}