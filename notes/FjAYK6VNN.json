{"title":"前端面试","content":"## 页面布局\n\n* 左右宽度固定中间自适应\n* 上下高度固定中间自适应 float( 清除浮动 ) positon( 子元素都脱离文档流 ) flexbox\n  table（高度同时增高） grid 解决方案间的优缺点兼容性业务上使用\n\n## css 盒模型\n\n### 基本概念：标准模型 + IE 模型\n\n* `border` `padding` `margin` `content`\n\n### 标准模型和 IE 模型的区别\n\n* 标准模型 : `content-box`\n* IE: `border-box`\n\n### css 如何设置这两种模型\n\n`box-sizing: content-box( 默认 )` `box-sizing: border-box`\n\n### js 如何获取盒模型对应的宽和高\n\n* `dom.style.width/height` 只能取内联的宽高\n* `dom.currentStyle.width/height` 及时运行完的渲染的宽高（只有 IE 支持）\n* `window.getComputedStyle(dom).width/height` 及时运行完的渲染的宽高（只有 IE 支\n  持）支持 chrome、firefox\n* `dom.getBoundingClientRect().width/height` 及时运行完的渲染的宽高（只有 IE 支\n  持，计算元素的绝对位置，相对于左定点的视窗\n\n### 边距重叠\n\n父子元素、兄弟元素\n\n### BFC(block fomatting context) 块级格式化上下文\n\n解决边距重叠\n\n### 概念\n\n* 处于同一个 BFC 中的元素相互影响，可能会发生 margin collapse；\n* BFC 在页面上是一个独立的容器，容器里面的子元素不会影响到外面的元素，反之亦然；\n* 计算 BFC 的高度时，考虑 BFC 所包含的所有元素，包括浮动元素也参与计算；\n* 浮动盒的区域不会叠加到 BFC 上\n\n### 创建 bfc\n\n* 浮动（float 的值不为 none）；\n* 绝对定位元素（position 的值为 absolute 或 fixed）；\n* 行内块（display 为 inline-block）表格单元（display 为 table、table-cell 、\n  table-caption 等 HTML 表格相关属性）；\n* 弹性盒（display 为 flex 或 inline-flex）；\n* overflow 不为 visible\n\n### 使用场景\n\n* 清除内部浮动：对子元素设置浮动后，父元素会塌陷，高度为 0，将父元素设置为一个\n  BFC，常用设置为`overflow:hidden`\n* 垂直`margin`合并\n\n## DOM 事件\n\n### DOM 事件的级别\n\n* `DOM0` `element.onclick=function(){}`\n* `DOM2` `element.addEventListener('click', function(){}, false)`\n* `DOM3` `element.addEventListener('keyup', function(){}, false)`事件添加了很多\n\n### DOM 事件模型\n\n* 冒泡\n* 捕获\n\n### DOM 事件流\n\n捕获 -> 目标阶段 -> 冒泡 ( 上传到 window 对象）\n\n### DOM 事件捕获的具体流程\n\nwindow -> document -> html -> body ->...-> 目标元素\n\n### Event 对象的常见应用\n\n* `event.preventDefault()` (a 链接跳转 )\n* `event.stopPropagation()` ( 阻止冒泡 )\n* `event.stopImmediatePropagation()` ( 事件响应优先级，注册两个 click 事件，阻止\n  第二个 )\n* `event.currentTarget()` ( 事件代理，当前绑定的时间 )\n\n### 自定义事件\n\n```js\nvar eve = new Event(\"custome\");\nev.addEventListener(\"custome\", function() {\n  console.log(\"custome\");\n});\nev.dispatchEvent(eve);\n```\n\n## HTTP 协议类\n\n### http 协议的主要特点\n\n简单快速 灵活 无连接 无状态\n\n### http 报文\n\n* 请求报文：请求行 部首 实体\n* 响应报文：状态行 部首 响应实体\n\n### http 方法\n\n* get 获取资源\n* head 获取报文部首\n* delete 删除资源\n* option\n* post 传输资源\n* put 更新资源\n* trace\n* connect\n\n### get 和 post 的区别\n\n* get 浏览器回退无害，Post 会再次提交\n* get 可以被收藏，post 不可以\n* get 浏览器会主动缓存，post 不会\n* get 请求参数会被保存在历史记录里，post 不会\n* get 的 url 参数长度有限制 ( 通常 2kb)，太长会被截断\n* get 的参数通过 url，post 通过 request body\n\n### http 状态码\n\n* 1xx 指示信息，表示请求已接收\n* 2xx 成功\n  * 200 OK\n  * 206 Partial Content 客户发送了一个带有 range 头的 GET 请求，服务器完成了它\n* 3xx 重定向\n  * 301 Moved Permanently 所请求的页面已经转移至新的 url\n  * 302 Found 所请求的页面已经临时转移至新的 url\n  * 304 Not Modified 原来缓冲的文档还可以继续使用\n* 4xx 客户端错误\n  * 400 客户端都语法错误\n  * 403 页面禁止被访问\n  * 404\n* 5xx 服务器错误\n\n### 持久连接\n\n* 是客户端到服务器的连接持续有效，当出现对服务器的后续请求时，避免了建立或者重新\n  建立连接\n* http1.1 版本支持\n\n### 管线化\n\n* 持久连接 : 请求 1-> 响应 1-> 请求 2-> 响应 2-> 请求 3-> 响应 3\n* 管线化：请求 1-> 请求 2-> 请求 3-> 响应 1-> 响应 2-> 响应 3\n* 通过持久连接完成，仅 HTTP1.1 支持技术\n* 支持 GET 和 HEAD 请求进行，而 POST 则有限制\n* 初次创建连接是不要启动管线化\n* 管线化不会影响到来顺序\n* 开启管线化不会带来性能的大幅度提升，许多服务器和代理程序对管线化的支持并不好，\n  所以现代浏览器 Chrome 和 Firefox 默认未开启管线化\n\n## 原型链\n\n### 创建对象有几种方法\n\n* 字面量 var o1 = {name: 'o1'}\n* var o11 = new object({name: 'o11'})\n* var M = function () {this.name = 'o2'}; var o2 = new M();\n* var P = {name: '03'}; var 03 = Object.create(P)\n\n### 原型 构造函数 实例 原型链\n\n### instanceof 的原理\n\n### new 运算符\n\n* 新对象被创建，继承自 foo.prototype( 原型对象 )\n* 构造函数被执行，this 会指定新实例\n* 构造函数返回一个对象，那么会取代 new 出来的结果\n\n### new 和 Object.create()\n\n```js\nvar func = function() {};\nvar o1 = new func();\n//func.prototype 原型对象\nvar o2 = Object.create(func.prototype);\no1 === o2; //flase\n\nObject.create = function(o) {\n  var F = function() {};\n  F.prototype = o;\n  return new F();\n};\n```\n\n## 安全类\n\n### CSRF(crose-site request forgey) 跨站请求伪造\n\n* 一定在注册网址登陆过、网址存在 api 漏洞，\n* 防御措施\n\n  * token 验证\n  * referer 验证（页面来源验证）\n  * 隐藏令牌（类似 cookie)\n  * 验证码\n\n### XSS(cross-site scripting 跨域脚本攻击攻击 )\n\n* 不需要任何的登录验证，只是注入脚本\n* 让插入的脚本不可执行\n* 在代码里对用户输入的地方和变量都需要仔细检查长度和对 ”<”,”>”,”;”,”’” 等字符做\n  过滤；\n* 任何内容写到页面之前都必须加以 encode，避免不小心把 html tag 弄出来。这一个层\n  面做好，至少可以堵住超过一半的 XSS 攻击\n* 避免直接在 cookie 中泄露用户隐私，例如 email、密码等等\n* 若是有用到 cookie, 设置为 http-only, 避免客户端的篡改\n\n## 通信类\n\n### 什么是同源策略及限制\n\n* 同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互\n* Cookie、 LocalStrage 、 IndexDB 无法读取\n* DOM 无法获取\n* ajax 请求无法发送\n\n### 前后端如何通信\n\n* Ajax 同源\n* webSocket\n* CORS\n\n### 如何创建 Ajax\n\n* XMLHttpRequest 对象的工作流程\n* 兼容性处理\n* 触发条件\n* 触发顺序\n\n```js\nfunction createXHR() {\n  var xhr = XMLHttpRequest\n    ? new XMLHttpRequest()\n    : new ActiveXObject(\"MSXHL.HTTP\");\n\n  return xhr;\n}\nxhr.onload = function() {\n  //206媒体文件，太大无法一次性传输\n  if (xhr.status === 200 || xhr.status === 304 || xhr.status === 206) {\n    var res = xhr.responseText;\n\n    if (typeof res === \"string\") {\n      res = JSON.parse(res);\n    }\n  }\n};\nvar xhr = createXHR();\nxhr.open(\"get\", \"index.html\", true);\n```\n\n### 跨域通信的几种方式\n\n* JSONP\n\n  * 利用 script 标签的异步加载\n\n  ```js\n  var script = document.createElement(\"script\");\n  script.src = \"http://www.baidu.com\";\n  document.body.insertBefore(script, document.body.firstChild);\n  ```\n\n* Hash\n\n  * url 中 # 后面的部分，hash 改变页面不刷新\n  * 页面 A 通过 iframe 或 frame 嵌入一个跨域的页面\n\n  ```js\n  var B = document.getElementsByTagName(\"iframe\");\n  B.src = B.src + \"#\" + \"data\";\n\n  window.onhashchange = function() {\n    var data = window.location.hash;\n  };\n  ```\n\n* postMessgae（html5 新增）\n  ```js\n  window.postMessgae(\"data\", \"http:B.com\"); //A窗口\n  window.addEventListener(\n    \"message\",\n    function(event) {\n      //B窗口\n      console.log(event.origin, event.source, event.data);\n    },\n    false\n  );\n  ```\n* webSocket\n* CORS( 支持跨域通信的 ajax, 添加一个 Access-Control-Allow-Origin)\n\n  ```js\n  fetch(url, {\n    method: \"get\"\n  })\n    .then(function(response) {})\n    .catch(function(err) {});\n  ```\n\n* 图片 ping\n* 利用 onload 和 onerror 事件处理\n\n## 面向对象\n\n### 类与实例\n\n* 类的声明\n\n```js\n  function C1() {\n    this.name = 'name';\n  }\n\n  class C2() {\n    this.name = 'name';\n  }\n\n  console.log(new C1(), new C2())\n```\n\n### 类与继承\n\n* 借助构造函数继承\n\n  * 子构造函数的内部调用父构造函数\n  * 父构造函数的 this 指向子构造函数的实例上\n  * 原型链上的东西无法被继承\n\n```js\nfunction Parent1() {\n  this.name = \"Parent1\";\n}\nParent1.prototype.say = function() {\n  console.log(\"hello\");\n};\n\nfunction Child1() {\n  Parent1.call(this); //apply\n  this.type = \"child1\";\n}\n```\n\n* 借助原型链实现继承\n  * 对象不隔离\n\n```js\nfunction Parent2() {\n  this.name = \"Parent2\";\n  this.play = [1, 2, 3];\n}\n\nfunction Child2() {\n  this.type = \"Child2\";\n}\n\nChild2.prototype = new Parent2();\n\nvar c2 = new Child2();\nvar c22 = new Child2();\n\nc2.play.push(4);\nc22.play; //[1, 2, 3, 4]\n```\n\n* 组合方式\n\n```js\n//构造函数执行了两次次\nfunction Parent3() {\n  this.name = \"Parent3\";\n  this.play = [1, 2, 3];\n}\nfunction Child3() {\n  this.type = \"Child3\";\n  Parent3.call(this);\n}\n\nChild3.prototype = new Parent3();\n\nvar p3 = new Child3();\nvar c33 = new Child3();\n\np3.play.push(4);\n\n//优化方式，构造函数执行了一次\nfunction Parent4() {\n  this.name = \"Parent4\";\n  this.play = [1, 2, 3];\n}\nfunction Child4() {\n  this.type = \"Child4\";\n  Parent3.call(this);\n}\nvar c4 = new Child4();\n\nChild4.prototype = Parent4.prototype;\n\nc4 instanceof Child4; //true\nc4 instanceof Parent4; //true， 实例无法判断是子的实例还是父实例\nc4.constructor; //Parent4，共用原型对象\n\n//优化2\nfunction Parent5() {\n  this.name = \"Parent5\";\n  this.play = [1, 2, 3];\n}\nfunction Child5() {\n  this.type = \"Child5\";\n  Parent3.call(this);\n}\n\nChild5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n```\n\n## 算法\n\n### 排序\n\n### 堆栈、队列、链表\n\n### 递归\n\n### 波兰式和逆波兰式\n\n## 渲染机制类\n\n### 什么是 DOCTYPE 及作用\n\n* 文件的合法性验证，告诉浏览器文档的类型\n* <!DOCTYPE html>  //html5\n* <!DOCTYPE HTML PUBLIC \".../strict.dtd\">\n* <!DOCTYPE HTML PUBLIC \".../loose.dtd\">\n  ### 浏览器渲染过程\n* html/xhtml/svg -> dom tree\n* style sheets -> cssom tree\n* dom tree + style tree -> render tree\n* paint\n* display\n\n## 重排 reflow\n\n* 增加删除节点，会导致 reflow 或 repaint\n* 移动 DOM\n* resize 窗口、滚动\n* 修改网页默认字体\n\n## 重绘 repaint\n\n* 页面显示不一样\n* document.createDocumentFragment\n\n## js 运行机制\n\n* 任务队列：同步任务、异步任务\n* 同步任务放在运行栈\n* 同步任务优先异步任务\n* 异步事假的放入事件和执行时间\n* 事件循环\n* 异步任务\n  * setTimeout setTimeInterval\n  * dom 事件\n  * es6 的 promise\n\n## 提高页面性能\n\n* 资源压缩合并，减少 HTTP 请求\n* 非核心代码异步加载\n  * 动态脚本加载\n  * async（加载完之后立即执行，如果是多个，与顺序无关，保证脚本无依赖）\n  * defer(html 解析完毕后执行，如果是多个，按加载顺序执行 )\n* 利用浏览器缓存\n* cdn\n* 预解析 dns\n  * `<link rel=\"dns-prefetch\" href=\"\">`\n  * `<meta http-equiv=\"x-dns-prefetch-control\" content='on'>`\n\n```js\nfunction createXML() {\n  var xml = XMLHTTPRequest\n    ? new XMLHTTPRequest()\n    : new ActiveXObject(\"Microsoft.XMLHTTP\");\n\n  return xml;\n}\n\nvar xml = createXHR();\nxml.onreadystatechange = function() {\n  if (xml.readyState == 4) {\n    if (xml.status == 200 || xml.status == 304) {\n      var res = xml.responseText;\n\n      if (typeof res === \"string\") {\n        res = JSON.parse(res);\n      }\n    } else {\n    }\n  }\n};\n\nxml.open(\"get\", \"index.html\", true);\nxml.send();\n```\n\n- 随机打乱数组\n```\n[].sort(() => 0.5 - Math.random())\n\n洗牌算法\n\nflatten\nJSON.parse(\"[\" + JSON.stringify(arr).replace(/[\\[\\]]/g, '') + ']')\n```","tags":[],"folderPathname":"/font/面试","data":{},"createdAt":"2020-08-07T02:31:18.808Z","updatedAt":"2020-11-23T01:55:32.900Z","trashed":false,"_id":"note:FjAYK6VNN","_rev":"5-334b2963c212ea02d73633f0010ed4c1"}