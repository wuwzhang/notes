{"title":"第21期","content":"## 2021/02/25\n## 每周资讯 - 第`21`期\n### 1. `F2C`流程可视化工具库 - `iMove`\n> `F2C`即`Flow 2 Code`，即通过流程可视化编排来产生代码\n\n`iMove`最近几周一直处于`github trending`, 还曾一度登上第一名\n\n#### 那`iMove`是什么？\n- 它是个工具，无侵入性。\n- 双击编写函数，编排后的流程可以导出可执行代码，便于在具体项目里做集成。\n- 测试方便，右键直接执行，此处有创新。\n- 让开发像运营配置一样完成功能开发，做到复用和`Lowcode`\n\n![](https://segmentfault.com/img/remote/1460000039017806)\n\n#### 前端开发痛点\n- `UI`老变，导致开发必须跟紧\n- 逻辑挑战，开发也必须改代码，很多后端处理逻辑都在里面\n- 组合接口，这是历史原因，主要是和后端配合导致的。没有 `Node BFF`层，都由组件来做，会问题非常多\n\n假如有一个**详情页购买按钮**的需求：\n- 获取详情页的商品信息\n- 商品信息包含以下\n  - 当前用户是否已经领券\n  - 商品领券是需要关注店铺还是加入会员\n- 根据返回的商品信息，购买按钮有以下几种形态\n  - 如果已经领券，按钮展示 \"已领券 + 购买\"\n  - 如果没有领券\n    - 如果领券需要关注店铺，按钮展示 \"关注店铺领券 + 购买\"\n    - 如果领券需要加入会员，按钮展示 \"加入会员领券 + 购买\"\n  - 异常情况时，展示兜底样式\n- 注意：如果用户未登录，唤起登录页\n\n伪代码如下\n```js\n// 检查登录\nconst checkLogin = () => {\n  return requestData('/is/login').then((res) => {\n    const {isLogin} = res || {};\n    return isLogin;\n  }).catch(err => {\n    return false;\n  });\n};\n\n// 获取详情页数据\nconst fetchDetailData = () => {\n  return requestData('/get/detail/data').then((res) => {\n    const {\n      hasApplied,\n      needFollowShop,\n      needAddVip,\n    } = res;\n    if(hasApplied) {\n      setStatus('hasApplied');\n    } else {\n      if(needFollowShop) {\n        setStatus('needFollowShop');\n      } else if(needAddVip) {\n        setStatus('needAddVip');\n      } else {\n        setStatus('exception');\n      }\n    }\n  }).catch(err => {\n    setStatus('exception');\n  });\n};\n\ncheckLogin().then(isLogin => {\n  if(isLogin) {\n    return fetchDetailData();\n  } else {\n    goLogin();\n  }\n});\n```\n\n上述例子虽然复杂度不高，但是背后的沟通和理解成本其实并不低，假如某天你接手了一个逻辑很复杂的他人项目，这其中的维护成本是非常高的\n\n而这也是`iMove`所解决的问题之一\n\n`iMove`将代码逻辑用流程图的形式展示出来，似产品的业务逻辑一目了然。除外，`iMove`中的每个节点都是支持编写代码的，而流程图的走向又决定了图中节点的执行顺序，可以说**\"流程可视化即天然的代码注释\"**。\n\n所以在 \"易读性\" 和 \"可维护性\" 上：\n`iMove`流程可视化的形式 > 产品经理的`PRD`文字描述形式 > 程序代码形式\n\n#### `iMove`优势\n##### 逻辑可复用\n在`iMove`中，每个可复用的代码片段都可以被封装成流程图中的节点。当想在不同项目中复用逻辑的时候，直接引入对应的节点/子流程即可，每个节点还支持参数配置，进一步提升了节点的复用性，使用体验可以说是非常简单了\n\n再往后设想一步，假如`iMove`已经在某个业务场景中沉淀了一定量的业务节点，当下次再遇到相似的业务需求时，逻辑部分是否可以直接复用现成的节点拼装而成。可以大大提升研发效率，缩短项目的研发周期\n##### 面向函数\n流程图的每个节点导出都是一个函数，只要有`JavaScript`经验，就没有上手成本。把他当做一个普通的`js`包导入即可使用。\n##### 流程可视化\n`iMove`是基于`F2C`的开发方式，他的好处是逻辑更直观、更好理解\n##### 逻辑/UI 解耦\n当你使用`iMove`开发之后就会发现：组件代码自然而然就拆成了 \"业务逻辑\" + \"UI样式\"。而且，不同版本的`UI`可以维护多套，但业务逻辑部分只要交给 iMove 维护一套即可。这样的开发方式不仅可以最大程度地复用业务逻辑代码，而且还提高了项目的可维护性\n##### 更简单的代码测试\n`iMove`支持**浏览器端在线运行节点代码**, 当完成一个节点的函数功能时，你随时可以在浏览器端`mock`各种输入来测试该节点的运行结果是否符合你的预期\n\n在无须引入测试框架、脱离上下文环境的前提下，你就可以单独对某一个节点的函数进行测试，这大大降低了代码测试的成本和门槛\n##### 无语言/场景限制\n`iMove`并没有使用语言和场景的限制。也就是说，不仅可以用 `iMove`编排前端项目中的`js`代码，同样也可以用`iMove`编排后端项目中的`java`代码，甚至其他场景的其他语言。而这一切，其实最终只取决于`iMove`将流程图编译出码成什么语言\n\n#### 相关文章\n- [登上 Github 趋势榜，iMove 原理技术大揭秘!](https://segmentfault.com/a/1190000039017794)\n- [github - iMove](https://github.com/imgcook/imove)\n- [2021 年前端趋势预测 - 狼叔](https://segmentfault.com/a/1190000039184240)\n\n### 2. [`free-for-dev`：对开发人员和基础设施具有兴趣的免费的SaaS，PaaS和IaaS产品列表 ](https://github.com/ripienaar/free-for-dev)\n\n#### 相关文章\n- [free-for-dev - github](https://github.com/ripienaar/free-for-dev)\n\n## 30 seconds of code\n### 目标\n实现一个converge函数，它接收一个函数a和一个函数数组b作为参数，并返回的函数；该返回的函数接收的参数将应用于converge函数的第二个参数函数数组b，函数数组b的执行结果作为参数传个converge函数的第一个参数函数a，并返回函数a的执行结果\n\n### 样例输出: \n```js\nconst average = converge((a, b) => a / b, [\n  arr => arr.reduce((a, v) => a + v, 0),\n  arr => arr.length\n]);\n\nconst over10 = converge((a, b) => a > b, [() => 10, arr => arr.sort().slice(-1)])\n\naverage([1, 2, 3, 4, 5, 6, 7]);  // 4\nover10([1, 2, 3, 4, 5, 6, 7]); // false\n```\n### 参考实现\n```js\nconst converge = (converger, fns) => (...args) =>\n  converger(...fns.map(fn => fn.apply(null, args)));\n```\n## 每日一问\n> 从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？\n\n## 每日二问\n> null，undefined 的区别\n\n\n### 上期的答案\n#### 第一题\n> 以下方法判断数组最准确的是\n\n- A、 typeof arr\n- B、 arr.constructor.name === 'Array'\n- C、 arr instanceof Array \n- D、Object.prototype.toString.call(arg) === '[object Array]'\n\n- 答案`D、Object.prototype.toString.call(arg) === '[object Array]'`\n- `constructor.name`可以被篡改\n- `instanceof`在跨`frame`对象构建的场景下会失效\n\n#### 第二题\n> 以下哪些选项可以将集合A转化为数组（ ）\n\n- A、Array.form(A)\n- B、[].slice.apply(A)\n- C、[…A]\n- D、[].map.call(A, o => o)\n\n- 答案`A、B、C、D`\n- A：可以把对象转换成真正的数组\n- B：slice()方法可从已有的数组中返回选定的元素\n- C：展开运算符，把A集合的元素展开后，用数组[]承载，返回新的数组\n- D：map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-02-25T01:39:30.629Z","updatedAt":"2021-02-25T16:30:52.854Z","trashed":false,"_id":"note:pNUI6KugK","_rev":"283-95e0dcec841648c7aa37d086286da4b2"}