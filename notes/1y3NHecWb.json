{"_id":"note:1y3NHecWb","title":"第65期","content":"## 2021/08/04\n## 每周资讯 - 第`65`期\n### 1. 自如客APP裸眼3D效果的实现\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f2e1f76b8a84bfba9cf028e4cb3f409~tplv-k3u1fbpfcp-watermark.image)\n#### 背景\n移动端界面设计如此火热的今天，各类大厂的设计规范和设计语言已经非常的成熟，我们想做一些在这套成熟的设计规范之外的尝试和创新，所以有别于传统的banner交互形式成为了我们的发力点。\n#### 设计理念\n由于 app 版面空间有限，除了功能导向、阅读习惯和设计美观外，自如想在既定的框下，做一下不同的设计尝试，哪怕这种尝试只能提升用户1%的观感。可能租了几年自如的房子，用了几年自如客app，你可能也不会注意到一些小的细节。但如果哪天，作为用户的你突然发现了这个隐藏的“彩蛋”，看到了自如在这些小细节上的用心，我相信那天你将会对自如这个品牌有更深层次的认识和理解。\n\n裸眼 3D 技术一般都是应用在裸眼 3D 大屏、全息投影等等比较常见的场景中，在 APP 的banner上应用，的确也是一次全新的尝试。我们通过借助移动设备上的传感器、以及自身的屏显清晰度、画面呈现，将 2D 影像转化为景深效果，以呈现出不用 \"3D\" 眼镜就可看到的3D效果。\n\n#### 实现方式\n以下以Android为例，介绍一下该效果的实现方式。\n##### 分层\n自如客 app 的 banner 其实一直在创新当中，有专门注意过的同学可能知道，在裸眼 3D 效果之前，自如客 app 其实就已经实现了分层，当时为了实现更加自然和精致的切换效果：在每个 banner 滑入滑出的时候，底部其实会在原地进行渐显渐隐，内容会跟随手势滑入滑出。此次为了实现 3D 效果，我们在以前分层的基础上加了一层中景，将原有的前景拆分为前景和中景。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b966ea60234107b6a5e2e44dbc299c~tplv-k3u1fbpfcp-watermark.image)\n\n上图的 sl_bg 为背景，pv_middle 为中景，sl 为前景\n\n由于切换的交互，实际上 banner 使用了两个 viewpager 进行了联动。背景在最底层的 viewpager 里面，中景和前景在另外一个 viewpager 里。\n\n##### 跟手位移\n\n打开自如客 app 后，用户操作设备可以明显感受到画面的错位移动，造成视觉上的景深效果。这种错位移动其实就是借助设备本身的传感器来实现的，具体实现方式是我们让中景始终保持不动，同时从设备传感器获取当前设备对应的倾斜角，根据倾斜角计算出背景和前景的移动距离，然后执行背景和前景移动的动作。如下图所示：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab25341a2cd84042ab52e63e056606d9~tplv-k3u1fbpfcp-watermark.image)\n\n为了使用的方便，我们封装了一个 SensorLayout，专门用于根据设备的倾斜角执行内容的位移； SensorLayout 内部的主要实现：\n\n##### 注册对应的传感器\n```java\nmSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);\n// 重力传感器\nmAcceleSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n// 地磁场传感器\nmMagneticSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\n\nmSensorManager.registerListener(this, mAcceleSensor, SensorManager.SENSOR_DELAY_GAME);\nmSensorManager.registerListener(this, mMagneticSensor, SensorManager.SENSOR_DELAY_GAME);\n```\n\n#### 计算偏转角度\n```java\nif (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {\n    mAcceleValues = event.values;\n}\nif (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {\n    mMageneticValues = event.values;\n}\n\nfloat[] values = new float[3];\nfloat[] R = new float[9];\nSensorManager.getRotationMatrix(R, null, mAcceleValues, mMageneticValues);\nSensorManager.getOrientation(R, values);\n// x轴的偏转角度\nvalues[1] = (float) Math.toDegrees(values[1]);\n// y轴的偏转角度\nvalues[2] = (float) Math.toDegrees(values[2]);\n```\n\n通过重力传感器和地磁场传感器，获取设备的偏转角度\n\n##### 根据偏转角度执行滑动\n```java\nif (mDegreeY <= 0 && mDegreeY > mDegreeYMin) {\n    hasChangeX = true;\n    scrollX = (int) (mDegreeY / Math.abs(mDegreeYMin) * mXMoveDistance*mDirection);\n} else if (mDegreeY > 0 && mDegreeY < mDegreeYMax) {\n    hasChangeX = true;\n    scrollX = (int) (mDegreeY / Math.abs(mDegreeYMax) * mXMoveDistance*mDirection);\n}\nif (mDegreeX <= 0 && mDegreeX > mDegreeXMin) {\n    hasChangeY = true;\n    scrollY = (int) (mDegreeX / Math.abs(mDegreeXMin) * mYMoveDistance*mDirection);\n} else if (mDegreeX > 0 && mDegreeX < mDegreeXMax) {\n    hasChangeY = true;\n    scrollY = (int) (mDegreeX / Math.abs(mDegreeXMax) * mYMoveDistance*mDirection);\n}\nsmoothScrollTo(hasChangeX ? scrollX : mScroller.getFinalX(), hasChangeY ? scrollY : mScroller.getFinalY());\n```\n\nmDegreeX 即为第二部中获取的偏转角度，mDegreeXMin 和mDegreeXMax 为 X 轴可发生偏转位移的角度最大值和最小值，mYMoveDistance 即为 Y 轴上的最大偏移距离（围绕X轴发生旋转，视图会沿Y轴上发生位移）；Y 轴上的偏转同理；就算好 X 轴和Y 轴的偏移距离后，使用 scroller 进行滑动；\n\n#### 实现总结\n\n读到这里，相信大家已经基本了解了这套banner的实现方案。Android 端在布局上进行了分层，中景位置不变，借助重力传感器和地磁场传感器获取偏转角度，根据角度使背景和前景进行错位移动。iOS端的实现原理也基本一致，不再赘述。\n\n#### 相关文章\n- [自如客APP裸眼3D效果的实现](https://juejin.cn/post/6989227733410644005?from=main_page)\n\n### 2. [感谢 compose 函数，让我的代码屎山????逐渐美丽了起来~](https://juejin.cn/post/6989020415444123662?from=main_page)\n曾经有一段优美的代码放在我面前，我没有珍惜。直到现在每天面对代码屎山手足无措时，才追悔莫及！尘世间最大的痛苦莫过于此，如果上天给我再来一次的机会，我一定对这段代码说三个字 —— 六，六，六！！！\n#### 相关文章\n- [感谢 compose 函数，让我的代码屎山????逐渐美丽了起来~](https://juejin.cn/post/6989020415444123662?from=main_page)\n## 30 seconds of code\n### 目标\n返回指定文件中的行数组\n\n### 样例输出: \n```js\n/*\ncontents of test.txt :\n  line1\n  line2\n  line3\n  ___________________________\n*/\nlet arr = readFileLines('test.txt');\nconsole.log(arr); // ['line1', 'line2', 'line3']\n```\n### 参考实现\n```js\nconst fs = require('fs');\n\nconst readFileLines = filename =>\n  fs\n    .readFileSync(filename)\n    .toString('UTF8')\n    .split('\\n');\n```\n## 每日一问\n> 介绍下前端加密的常见场景和方法\n\n## 每日二问\n> 说说浏览器和 Node 事件循环的区别\n\n### 上期的答案\n#### 每日一问\n> 改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。\n\n```js    \nfor (var i = 0; i< 10; i++){\n\tsetTimeout(() => {\n\t\tconsole.log(i);\n    }, 1000)\n}\n```\n\n```js\n// 解法一：\nfor (let i = 0; i< 10; i++){\n  setTimeout(() => {\n    console.log(i);\n  }, 1000)\n}\n\n// 解法二：\nfor (var i = 0; i< 10; i++){\n  ((i) => {\n    setTimeout(() => {\n      console.log(i);\n    }, 1000)\n })(i)\n}\n\n// 解法三：\nfor (var i = 0; i < 10; i++) {\n  setTimeout(i => {\n    console.log(i);\n  }, 1000, i)\n}\n\n// 解法四：\nfor(var i = 0; i < 10; i++){ \n  try{\n     throw i;\n  }catch(i){\n     setTimeout(() => { console.log(i); },1000)    \n  }\n}       \n```\n\n#### 每日二问\n> 请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']\n\n\n```js\nlet arr1 = [\"A1\", \"A2\", \"B1\", \"B2\", \"C1\", \"C2\", \"D1\", \"D2\"];\nlet arr2 = [\"A\", \"B\", \"C\", \"D\"];\nconsole.log(\n  [...arr1, ...arr2]\n    .sort(\n      (v2, v1) => (\n        v2.codePointAt(0) - v1.codePointAt(0) ||\n        v1.length - v2.length ||\n        v2.codePointAt(1) - v1.codePointAt(1)\n      )\n    )\n);\n```","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-08-03T13:28:04.927Z","updatedAt":"2021-08-03T14:16:06.819Z","trashed":false,"_rev":"Dn0KgfETl"}