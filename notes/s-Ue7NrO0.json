{"title":"第25期","content":"## 2021/03/12\n## 每周资讯 - 第`25`期\n### 1. 更推荐`pnpm`而不是`npm/yarn`?\n> Fast, disk space efficient package manager\n\n一个业内一款出色的包管理器——`pnpm`。目前`GitHub`已经有`star 10.4k`，现在已经相对成熟且稳定了。\n\n它由`npm/yarn`衍生而来，但却解决了`npm/yarn`内部潜在的`bug`，并且极大了地优化了性能，扩展了使用场景\n\n它作为杀手锏的两个优势在于:\n\n- 包安装速度极快；\n- 磁盘空间利用非常高效。\n\n#### 特性概览\n##### 1. 速度快\n`pnpm`安装包的速度究竟有多快？先以`React`包为例来对比一下:\n![](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1SHYqqZQnlI7z81cLqexr6vKogu3JBunK61xl9icybWicIa2vcrV8l7DHel71kLmrpmibtp3hAR6Xcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n可以看到，包安装的速度都是明显优于`npm/yarn`。\n\n对于`yarn PnP`模式，直接去掉`node_modules`，将依赖包内容写在磁盘，节省了`node`文件`I/O`的开销，这样也能提升安装速度[详细查看这篇文章](https://loveky.github.io/2019/02/11/yarn-pnp/)\n\n![](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1SHYqqZQnlI7z81cLqexr6dObyIsvFPpXibmZYLCobB79QmfBvAVpJ8Iz6DCztDtBvicujHibJbgt9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n从中可以看到，总体而言，`pnpm`的包安装速度还是明显优于`yarn PnP`的\n\n##### 2. 高效利用磁盘空间\n`pnpm`内部使用基于内容寻址的文件系统来存储磁盘上所有的文件\n- `pnpm`不会重复安装同一个包。用`npm/yarn`的时候，如果 100 个项目都依赖`lodash`，那么`lodash`很可能就被安装了`100`次，磁盘中就有`100`个地方写入了这部分代码。但在使用`pnpm`只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用`hardlink`\n- 即使一个包的不同版本，`pnpm`也会极大程度地复用之前版本的代码。举个例子，比如`lodash`有`100`个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入`101`个文件，而是保留原来的`100`个文件的 `hardlink`，仅仅写入那一个新增的文件。\n\n##### 3. 支持`monorepo`\n`pnpm`与`npm/yarn`另外一个很大的不同就是支持了`monorepo`，体现在各个子命令的功能上，比如在根目录下`pnpm add A \\-r`, 那么所有的 `package`中都会被添加`A`这个依赖，当然也支持`--filter`字段来对`package`进行过滤。\n\n##### 4. 安全性高\n之前在使用`npm/yarn`的时候，由于`node_module`的扁平结构，如果`A` 依赖`B`，`B`依赖`C`，那么`A`当中是可以直接使用`C`的，但问题是`A`当中并没有声明`C`这个依赖。因此会出现这种非法访问的情况。但`pnpm`脑洞特别大，自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性，具体怎么体现安全、规避非法访问依赖的风险的，后面再来详细说说。\n\n#### 依赖管理\n##### 1. `npm/yarn install`原理\n执行`npm/yarn install`之后,首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:\n\n1. 将依赖包的版本区间解析为某个具体的版本号\n2. 下载对应版本依赖的`tar`包到本地离线镜像\n3. 将依赖从离线镜像解压到本地缓存\n4. 将依赖从缓存拷贝到当前目录的`node_modules`目录\n\n那么，这些依赖在`node_modules`内部是什么样的目录结构呢?\n\n在`npm1`、`npm2`中呈现出的是嵌套结构，比如下面这样:\n```\nnode_modules\n└─ foo\n   ├─ index.js\n   ├─ package.json\n   └─ node_modules\n      └─ bar\n         ├─ index.js\n         └─ package.json\n```\n如果`bar`当中又有依赖，那么又会继续嵌套下去，存在下面的问题\n- 依赖层级太深，会导致文件路径过长的问题，尤其在`window`系统下。\n- 大量重复的包被安装，文件体积超级大。比如跟`foo`同级目录下有一个`baz`，两者都依赖于同一个版本的`lodash`，那么`lodash`会分别在两者的`node_modules`中被安装，也就是重复安装。\n- 模块实例不能共享。比如`React`有一些内部变量，在两个不同包引入的 `React`不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的`bug`。\n\n\n从`npm3`开始，包括`yarn`，都着手来通过扁平化依赖的方式来解决这个问题\n\n```\nnode_modules\n├─ foo\n|  ├─ index.js\n|  └─ package.json\n└─ bar\n   ├─ index.js\n   └─ package.json\n```\n所有的依赖都被拍平到node_modules目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的node_modules当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。\n\n但仔细想想这种扁平化的处理方式，它真的就是无懈可击吗？\n- 依赖结构的不确定性。\n- 扁平化算法本身的复杂性很高，耗时较长。\n- 项目中仍然可以非法访问没有声明过依赖的包\n\n###### 关于不确定性\n假如现在项目依赖两个包`foo`和`bar`，这两个包的依赖又是这样的:\n![](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1SHYqqZQnlI7z81cLqexr6zqvCABStTdXffqH5jwvZ08YrU5F81qJ98EpwhZmkIxWwRlCzXK9fxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n那么`npm/yarn install`的时候，通过扁平化处理之后，究竟是这样\n![](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1SHYqqZQnlI7z81cLqexr608YHrICgvIzZ8dqHXRxflc9miaBJ9GJFaJLzW5vTcU6Mjk5FQibQep9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n还是这样？\n![](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib1SHYqqZQnlI7z81cLqexr6ojMRcrsHSKGyibPZgwicibfaBvkg4fEdribLKYhiapqGicFj69ic9RKOk6ZsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n这就是为什么会产生依赖结构的不确定问题，也是`lock`文件诞生的原因，无论是`package-lock.json`(`npm 5.x`才出现)还是`yarn.lock`，都是为了保证`install`之后都产生确定的`node_modules`结构。\n\n尽管如此，`npm/yarn`本身还是存在扁平化算法复杂和`package`非法访问的问题，影响性能和安全。\n\n##### 2. `pnpm`依赖管理\n`pnpm`的作者`Zoltan Kochan`发现`yarn`并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器，开创了一套新的依赖管理机制，现在就让我们去一探究竟。\n\n以安装`express`为例，我们新建一个目录，执行:\n\n```shell\npnpm install express\n```\n\n```yaml\n # node_modules:\n.pnpm\n.modules.yaml\nexpress\n```\n我们直接就看到了`express`，但值得注意的是，这里仅仅只是一个软链接，里面并没有`node_modules`目录，如果是真正的文件位置，那么根据 `node`的包加载机制，它是找不到依赖的。那么它真正的位置在哪呢？\n\n```yaml\n# .pnpm\n▾ node_modules\n  ▾ .pnpm\n    ▸ accepts@1.3.7\n    ▸ array-flatten@1.1.1\n    ...\n    ▾ express@4.17.1\n      ▾ node_modules\n        ▸ accepts\n        ▸ array-flatten\n        ▸ body-parser\n        ▸ content-disposition\n        ...\n        ▸ etag\n        ▾ express\n          ▸ lib\n            History.md\n            index.js\n            LICENSE\n            package.json\n            Readme.md\n```\n`.pnpm`目录下虽然呈现的是扁平的目录结构，但仔细想想，顺着软链接慢慢展开，其实就是嵌套的结构\n\n将包本身和依赖放在同一个`node_module`下面，与原生`Node`完全兼容，又能将`package`与相关的依赖很好地组织到一起，设计十分精妙。\n\n#### 再谈安全\n`pnpm`这种依赖管理的方式也很巧妙地规避了非法访问依赖的问题，也就是只要一个包未在`package.json`中声明依赖，那么在项目中是无法访问的\n\n但在`npm/yarn`当中是做不到的，那你可能会问了，如果`A`依赖`B`，`B`依赖`C`，那么`A`就算没有声明`C`的依赖，由于有依赖提升的存在，`C`被装到了`A`的`node_modules`里面，那我在`A`里面用`C`，跑起来没有问题呀，我上线了之后，也能正常运行啊。不是挺安全的吗？\n\n还真不是。\n\n- 第一，你要知道`B`的版本是可能随时变化的，假如之前依赖的是`C@1.0.1`，现在发了新版，新版本的`B`依赖`C@2.0.1`，那么在项目`A`当中`npm/yarn install`之后，装上的是`2.0.1`版本的`C`，而`A`当中用的还是`C`当中旧版的`API`，可能就直接报错了。\n- 第二，如果`B`更新之后，可能不需要`C`了，那么安装依赖的时候，`C`都不会装到`node_modules`里面，`A`当中引用`C`的代码直接报错。\n- 第三，在`monorepo`项目中，如果`A`依赖`X`，`B`依赖`X`，还有一个 `C`，它不依赖`X`，但它代码里面用到了`X`。由于依赖提升的存在，`npm/yarn`会把 X 放到根目录的`node_modules`中，这样`C`在本地是能够跑起来的，因为根据`node`的包加载机制，它能够加载到`monorepo`项目根目录下的`node_modules`中的`X`。但试想一下，一旦`C`单独发包出去，用户单独安装`C`，那么就找不到`X`了，执行到引用`X`的代码时就直接报错了\n\n`npm`也有想过去解决这个问题，指定`--global-style`参数即可禁止变量提升，但这样做相当于回到了当年嵌套依赖的时代，一夜回到解放前，前面提到的嵌套依赖的缺点仍然暴露无遗。\n\n`npm/yarn`本身去解决依赖提升的问题貌似很难完成，不过社区针对这个问题也已经有特定的解决方案: [dependency-check](https://github.com/dependency-check-team/dependency-check)\n\n但不可否认的是，`pnpm`做的更加彻底，独创的一套依赖管理方式不仅解决了依赖提升的安全问题，还大大优化了时间和空间上的性能。\n\n#### 相关文章\n- [为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://mp.weixin.qq.com/s/PFFkWxfUkyw3iKS3Mukrpw)\n- [yarn PnP介绍](https://loveky.github.io/2019/02/11/yarn-pnp/)\n- [dependency-check](https://github.com/dependency-check-team/dependency-check)\n\n### 2. 高颜值的第三方网易云播放器`YesPlayMusic`\n基于`Vue`全家桶的跨平台项目\n\n![](image-km4n8nv9.png)\n#### 相关文章\n- [YesPlayMusic - github 6.1k star](https://github.com/qier222/YesPlayMusic)\n\n## 30 seconds of code\n### 目标\n实现一个`get`函数, 传入一组属性值时，返回响应对象的索引值\n\n### 样例输出: \n```js\nconst obj = {\n  selector: { to: { val: 'val to select' } },\n  target: [1, 2, { a: 'test' }],\n};\nget(obj, 'selector.to.val', 'target[0]', 'target[2].a');\n// ['val to select', 1, 'test']\n```\n\n### 参考实现\n```js\nconst get = (from, ...selectors) =>\n  [...selectors].map(s =>\n    s\n      .replace(/\\[([^\\[\\]]*)\\]/g, '.$1.')\n      .split('.')\n      .filter(t => t !== '')\n      .reduce((prev, cur) => prev && prev[cur], from)\n  );\n```\n## 每日一问\n> 白屏时间`first paint`和可交互时间`dom ready`的关系是（ ）\n- A、先触发first paint ，后触发dom ready\n- B、先触发dom ready，后触发first paint\n- C、一起触发\n- D、没关系\n\n## 每日二问\n> target、currentTarget的区别？\n\n### 上期的答案\n#### 第一题\n> `Math.ceil(-3.14)` 的结果是（B），`Math.floor(-3.14)` 的结果是（C）\n\n- A．-3.14 \n- B．-3 \n- C．-4 \n- D．3.14\n\n#### 第二题\n> 找到数组 [-1, -2, 1, 10, 4, 5, 8] 中的最大值，至少写出两种方法\n\n```js\nvar arr = [-1, -2, 1, 10, 4, 5, 8];\n\n// 第一种\nvar max1 = Math.max.apply(null, arr);\n\n// 第二种\nvar max2 = arr.sort(function(a, b){\n    return b - a;\n})[0];\n\n// 第三种\nvar max3 = -Infinity;\nfor (var i = 0; i < arr.length; i++) {\n    if (max3 < arr[i]) {\n        max3 = arr[i];\n    }\n}\n```\n","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-03-09T02:43:18.171Z","updatedAt":"2021-03-12T01:26:36.265Z","trashed":false,"_id":"note:s-Ue7NrO0","_rev":"197-12b03c160a1013765e2c3c041130ba84"}