{"title":"第8期","content":"## 2021/01/18\n\n## 每日资讯\n### 1. `Facebook`重构，使用原子化`CSS`\n> 随着 Facebook 和 Twitter 最近的产品部署，我认为一个新的趋势正在缓慢增长:Atomic CSS-in-JS\n\n`Facebook`抛弃了`Sass/Less`，采用原子化 \n`CSS`模式，使主页减少了`80%`的`CSS`体积\n\n#### 什么是原子`CSS`\n> 几种CSS方法，见下文分割线后\n\n原子`CSS`就像是实用工具优先（`utility-first`）`CSS` 的一个极端版本: 所有 `CSS `类都有一个唯一的 `CSS` 规则\n\n```css\n/* 原子 CSS */\n.bw-2x {\n  border-width: 2px;\n}\n.bss {\n  border-style: solid;\n}\n.sans {\n  font-style: sans-serif;\n}\n.p-1x {\n  padding: 10px;\n}\n/* 不是原子 CSS 因为这个类包含了两个规则 */\n.p-1x-sans {\n  padding: 10px;\n  font-style: sans-serif;\n}\n\n```\n使用原子样式表，在新增功能时，样式表的体积增长会变得缓慢。且一旦准备好实用工具库，它不会有很大的改动，可以更好的缓存它。可移植性好，可用于任何应用程序。\n\n但是它同样存在一些问题。手工编写的原子`CSS`，需要精心制定命名约定，且难以保证这个约定易于使用、保持一致性，而且不会随着时间的推移而变得臃肿。而且一般要有一个不错的原子`CSS`库才能开始开发，同时还需要学习成本来适应它\n\n#### Tailwind前来救援\n> Tailwind解决了上述的一些问题\n\n`Tailwind`提供了一些公用的命名约定。通过一个配置文件，你可以为你的网站生成一套专属的实用工具`CSS`\n\n```html\n<div class=\"w-12 h-12 flex shadow-md bg-red\">\n\t<div class=\"flex-shrink-0\">\n\t\t<p class=\"text-lg\"></p>\n\t</div>\n</div>\n```\n\n```js\n// tailwind.config.js\n// 自己设置spacing的值\nmodule.exports = {\n  theme: {\n    spacing: { // 同时控制margin/padding/width等，默认采用rem， 此时h-6就等于48px\n      '1': '8px',\n      '2': '12px',\n      '3': '16px',\n      '4': '24px',\n      '5': '32px',\n      '6': '48px',\n    }\n  }\n}\n```\n\n但`Tailwind`还是没有解决\n- 需要学习一套主观的命名约定\n- `CSS` 规则插入顺序仍然很重要\n- 未使用的规则可以轻松删除吗?\n- 我们如何处理剩下的一次性样式\n\n#### 与`CSS-in-JS`相比较\n`CSS-in-JS` 和实用工具/原子 `CSS` 有密切关系。这两种方法都提倡使用标签进行样式化\n\n- 全局命名空间\n- 依赖\n- 无用代码消除\n- 代码压缩\n- 共享常量\n- 非确定性（`Non-Deterministic`）解析\n- 隔离\n\n#### 相关工具\n- 适用于`VSCode`的智能`Tailwind`提示工具\n\n![](https://raw.githubusercontent.com/bradlc/vscode-tailwindcss/master/packages/tailwindcss-intellisense/.github/banner-dark.png)\n\n---\n一起整理的几种`css`模式，可能会有遗漏\n\n#### OOCSS\n> `css`的面向对象的加强版，每个`class`只处理一件事\n\n更像是短命名的一种变相的内联样式\n\n```css\n.size { width: 10px }\n.bgBlue { background:blue }\n```\n\n##### 优势\n- 避免冗余，更好的创建可复用的`class`\n- 打包体积小\n- 添加新功能时，样式表的增长缓慢\n- 变化小，可以更好的缓存\n- 可移植性好，可用于任何应用程序\n- 不用在命名上纠结\n\n##### 缺点\n- `class`零散、维护成本高\n- 修改`class`带来巨大风险\n- 缺少`class`的语义化\n- 要有一个不错的原子样式表才能开发\n- 如果是他人创建的原子样式表，要先学习类命名约定，有一定的学习成本\n\n#### SMACSS\n> 将`css`分为5个类\n\n- `Base`基本样式\n- `Layout`布局样式\n- `Module`模块样式\n- `State`状态样式\n- `Theme`主题样式\n\n##### 命名规则\n- `Base`基础元素，不需要命名，如(`div` `span`)\n- `Layout`使用前缀`l-`或 `layout-`\n- `Module`使用模块名命名，如文章`.articel`\n- `State`使用`.is-`前缀, 如`.is-show` `.is-hidden`\n- `Theme`使用`.theme-`前缀\n\n##### 优势\n- 拆分了主题、状态、布局，增强了`CSS`可读性\n\n#### BEM\n- `block` `element` `modifier`\n```css\n.article {}\n.article__label {} /* label 元素 */\n.article__label--selected {} /* label 元素处于被选中状态 */\n```\n\n#### ITCSS\n> 对`CSS`进行分层\n\n- `Settings` – 与预处理器一起使用，包含颜色、字体等定义\n- `Tools` – 工具与方法，比如 `mixins`，`Settings` 与 `Tools` 都不会产生任何 `css` 代码，仅仅是辅助函数与变量\n- `Generic` – 通用层，比如 `reset html`、`body` 的样式\n- `Elements` – 对通用元素的样式重置，比如 `a` `p` `div` 等元素的样式重置\n- `Objects` – 类似 `OOCSS` 中的对象，描述一些常用的基础状态\n- `Components` – 对组件样式的定义，一个 `UI` 元素基本由 `Objects` 与 `Components` 组成\n- `Utilities` – 工具类，比如 `.hidden`\n\n#### ECSS\n> `.nsp-Component_ChildNode-variant`\n\n- `nsp` 一个尽量简短的命名空间\n- `Component` 文件名\n- `ChildNode` 子元素名\n- `variant` 额外内容\n\n```html\n<div class=\"tl-MediaObject\">\n   <a href=\"#\" class=\"tl-MediaObject_Link\">\n      <img class=\"tl-MediaObject_Media\" src=\"mini.jpg\" alt=\"User\">\n   </a>\n   <div class=\"tl-MediaObject_Attribution\">@BF 14 minutes ago</div>\n</div>\n```\n\n#### 相关文章\n- [Atomic CSS-in-JS](https://sebastienlorber.com/atomic-css-in-js)\n- [tailwindcss](https://tailwindcss.com/)\n- [Facebook 重构：抛弃 Sass / Less ，迎接原子化 CSS 时代](https://juejin.cn/post/6917073600474415117)\n\n### 2. module-federation/module-federation-examples\n该存储库用于展示有关`Webpack 5`的新模块联合的示例\n\n#### 相关文章\n- [module-federation/module-federation-examples](https://github.com/module-federation/module-federation-examples)\n\n## 30 seconds of code\n### 目标\n根据数组中的键名获取对象的值\n\n### 样例输出: \n```js\nlet index = 2;\nconst data = {\n  foo: {\n    foz: [1, 2, 3],\n    bar: {\n      baz: ['a', 'b', 'c']\n    }\n  }\n};\ndeepGet(data, ['foo', 'foz', index]); // get 3\ndeepGet(data, ['foo', 'bar', 'baz', 8, 'foz']); // null\n```\n\n### 参考实现\n```js\nconst deepGet = (obj, keys) =>\n  keys.reduce(\n    (xs, x) => (xs && xs[x] !== null && xs[x] !== undefined ? xs[x] : null),\n    obj\n  );\n```\n\n## 每日一问\n\n> 以下代码的运行结果是？\n\n```js\nlet person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n```\n\n- A &nbsp;&nbsp;`null` \n- B &nbsp;&nbsp;`[null]` \n- C &nbsp;&nbsp;`[{}]` \n- D &nbsp;&nbsp;`[{name: 'Lydia}]` \n\n## 每日二问\n> 以下代码的`num`的值是？\n\n```js\nconst add = x => y => z => {\n\tconsole.log(x, y, z);\n\treturn x + y + z;\n};\n\nadd(4)(5)(6);\n```\n\n- A &nbsp;&nbsp;`4 5 6` \n- B &nbsp;&nbsp;`6 5 4`\n- C &nbsp;&nbsp;`4 function function` \n- D &nbsp;&nbsp;`undefined undefined 6`\n### 周五的答案\n#### 第一题\n- D\n- `Symbol`类型是不可枚举的。`Object.keys`方法返回对象上的所有可枚举的键属性\n\n#### 第二题\n- D\n- 在`firstFunction`中, `promise`进入微任务队列，其他后面的代码（`console.log('1')`）照常运行,`firstFunctio`n方法执行完毕，执行栈中宏任务队列被清空，此时开始执行微任务队列中的任务，`I have resolved`被打印出。\n- 在`secondFunction`方法中，通过`await`关键字，暂停了后面代码的执行，直到异步函数的值被解析才开始后面代码的执行。\n- [还不清楚 看这篇](https://juejin.cn/post/6844904077537574919dd)\n","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-02-22T06:57:35.897Z","updatedAt":"2021-03-09T02:16:22.347Z","trashed":false,"_id":"note:peEph8Hxi","_rev":"13-5403b81d41a4541efad2b3c9330e4193"}