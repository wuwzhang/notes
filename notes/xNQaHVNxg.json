{"_id":"note:xNQaHVNxg","title":"第47期","content":"## 2021/06/03\n## 每周资讯 - 第`47`期\n### 1. 卷积矩阵，让你的图片为所欲为\n实现如下的效果图的心愿墙，形状是一条由气泡组成的龙，每个每个气泡都会浮动，鼠标移上去变大，点击后展示心愿详情\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/862c493c8bd34b2e8dd3713f9be40d5f~tplv-k3u1fbpfcp-watermark.image)\n\n#### 拆解需求\n- 需求1：有鼠标交互效果\n- 需求2：气泡浮动\n- 需求3：气泡组成一条龙\n\n#### 思路\nHTML 5中的 canvas 元素是相当强大的，[getImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData) 方法可以对载入的图像直接进行位图操作。\n\n> 语法：ImageData ctx.getImageData(sx, sy, sw, sh);\n\n- 参数\n  - sx：将要被提取的图像数据矩形区域的左上角 x 坐标。\n  - sy：将要被提取的图像数据矩形区域的左上角 y 坐标。\n  - sw： 将要被提取的图像数据矩形区域的宽度。\n  - sh： 将要被提取的图像数据矩形区域的高度。\n- 返回值\n  - 一个[ImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData)对象，包含canvas给定的矩形图像数据。\n\n```js\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\nctx.rect(10, 10, 100, 100);\nctx.fill();\n\nconsole.log(ctx.getImageData(50, 50, 100, 100));\n// ImageData { width: 100, height: 100, data: Uint8ClampedArray[40000] }\n// Uint8ClampedArray 描述了一个一维数组，包含以 RGBA 顺序的数据，数据使用  0 至 255（包含）的整数表示。 \n```\n\nUint8ClampedArray 数组是怎么存每个像素点的 rgba 值的呢？\n![](https://segmentfault.com/img/bVX0RE?w=800&h=158)\n所以$length = canvas.width * canvas.height * 4$\n\n知道了这种关系，我们不妨把这个一维数组想象成二维数组，想象它是一个平面图，如图：\n![](https://segmentfault.com/img/bVX0RJ?w=868&h=870)\n\n\n一个格子代表一个像素\n- w = 图像宽度\n- h = 图像高度\n\n这样，我们可以很容易得到点`(x, y)`在一维数组中对应的位置。我们想一想，点(1, 1)坐标对应的是数组下标为0，点(2, 1)对应的是数组下标4，假设图像宽度为2*2，那么点(1，2)对应下标就是$index=((2 - 1)*w + (1 - 1))*4 = 8$。\n\n推导的公式为：$index = [(y - 1) w + (x - 1) ] * 4$\n\n其中利用卷积矩阵，可以通过几个简单的参数实现复杂的效果。\n\n所谓的矩阵的卷积，就是如下图显示的那样，当计算红色框中的数值的时候，分别先提取周围绿框中8个数字，然后与施加的那个矩阵中对应位置相乘，然后把各个乘积加在一起，就得到了最终的值了。\n\n![](http://docs.gimp.org/en/images/filters/examples/convolution-calculate.png)\n\n比如上图中的 42 是这么来的:\n```js\n  (40*0)+(42*1)+(46*0)\n+ (46*0)+(50*0)+(55*0)\n+ (52*0)+(56*0)+(58*0)\n= 42\n```\n\n比如下面这张图\n![](image-kpfizbfn.png)\n\n利用下面这个矩阵, 就立刻能够得到浮雕效果。\n$$\n  \\begin{bmatrix}\n   -6 & -3 & 0 \\\\\n   -3 & -1 & 3 \\\\\n   0 & 3 & 6\n  \\end{bmatrix}\n$$\n![](image-kpfj3bck.png)\n\n#### 代码实现\n先用图片搜索找一张龙的剪影\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b4df2d7b9b424fb431753167337851~tplv-k3u1fbpfcp-watermark.image)\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8098e5ef8d6b46288cfd2292dccc2b65~tplv-k3u1fbpfcp-watermark.image)\n\n##### 将图片绘制到`canvas`中\n```js\nvar canvas = document.getElementById(\"canvas\");\nvar ctx = canvas.getContext(\"2d\");\n\nvar image = new Image();\nimage.src = \"dragon.jpg\";\nimage.onload = function() {\n  canvas.width = image.width;\n  canvas.height = image.height;\n\n  ctx.drawImage(image, 0, 0);\n}\n```\n\n#### 获取并裁剪画布的点阵信息\n```js\nconst imageData = ctx.getImageData(0, 0, image.width, image.height).data;\nctx.fillStyle = \"#fff\";\nctx.fillRect(0, 0, image.width, image.height);\n\nconst gap = 6;  // 间隔，为了形成点阵\n\nfor (let y = 0; y < image.height; y += gap) {\n  for (let x = 0; x < image.width; x += gap) {\n    const ind = (image.width * y + x) * 4; // 参考上方的公式 index = [(y - 1) w + (x - 1)] * 4，此处为从0 开始遍历，不用-1\n    const [r, g, b] = imageData.slice(ind, ind + 3) // 不处理透明度\n\n    if (r + g + b === 0) { // 过滤掉了非黑色的像素\n      ctx.fillStyle = \"#000\";\n      ctx.fillRect(w, h, 4, 4);\n      \n      ...\n      // 渲染气泡时，换成render函数\n    }\n  }\n}\n\n```\n\n现在我们获得了这样一条龙的点阵信息\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab8c4d11d4e54e0980f0eb02b5426131~tplv-k3u1fbpfcp-watermark.image)\n\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74fea9a084a14630b925b091adfb6f6c~tplv-k3u1fbpfcp-watermark.image)\n\n\n#### 相关文章\n- [产品经理：你能不能用div给我画条龙？](https://juejin.cn/post/6963476650356916254)\n- [getImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData)\n- [ImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData)\n- [canvas-玩转每一个像素-滤镜](https://segmentfault.com/a/1190000011880686)\n\n### 2. [写给前端的跨平台方案、跨端引擎的本质](https://mp.weixin.qq.com/s/IyQPf3yn-mjBmWqeb8dYMg)\n近些年来，前端领域的跨端技术越来越多了：react native、weex、flutter、electron、kraken 等等。那么多跨端方案，他们有没有通用的思路？我们能不能从这么多方案中找出本质的原理？\n#### 相关文章\n- [写给前端的跨平台方案、跨端引擎的本质](https://mp.weixin.qq.com/s/IyQPf3yn-mjBmWqeb8dYMg)\n\n## 30 seconds of code\n### 目标\nGit aliases\n### 样例输出: \n```js\ngit cob feature-* // 等价于 git checkout -b feature-*\n```\n### 参考实现\n```js\ngit config --global alias.<alias> <command>\n```\n\n#### Useful aliases\n```shell\n[alias]\n  co = checkout\n  cob = checkout -b\n  coo = !git fetch && git checkout\n  br = branch\n  brd = branch -d\n  st = status\n  aa = add -A .\n  unstage = reset --soft HEAD^\n  cm = commit -m\n  amend = commit --amend -m\n  fix = commit --fixup\n  undo = reset HEAD~1\n  rv = revert\n  cp = cherry-pick\n  pu = !git push origin `git branch --show-current`\n  fush = push -f\n  mg = merge --no-ff\n  rb = rebase\n  rbc = rebase --continue\n  rba = rebase --abort\n  rbs = rebase --skip\n  rom = !git fetch && git rebase -i origin/master --autosquash\n  save = stash push\n  pop = stash pop\n  apply = stash apply\n  rl = reflog\n```\n## 每日一问\n> git cherry-pick，有什么作用？\n\n## 每日二问\n> 完成以下功能\n\n- 请用您认为最优化的方式，将arr中的type为4的数据过滤出来\n- 然后按相同的 name date（按天）合并value（value累加）\n- 然后按 value 降序(从大到小)排序\n- 最后每行按照 \"${name},${本地日期},售出${sum(value)}部\" 的格式，如：\"小米2,2017年06月08日,售出5部\", 打印(console.log)出来。可以使用es6。\n\n```js\nvar arr = [\n   {name:'小米1', value: 1,  type: 2, date: '2018-06-07T08:00:01.589Z' },\n   {name:'锤子T1', value: 1, type: 2, date: '2018-06-07T08:10:01.589Z' },\n   {name:'小米2', value: 1, type: 4, date: '2018-06-07T20:00:01.589Z' },\n   {name:'小米2', value: 4, type: 4, date: '2018-06-07T20:10:21.189Z' },\n   {name:'小米4', value: 1, type: 4, date: '2018-06-07T08:00:01.560Z' },\n   {name:'小米4', value: 2, type: 4, date: '2018-06-07T08:10:31.584Z' },\n   {name:'小米6', value: 1, type: 3, date: '2018-06-07T08:00:01.589Z' },\n   {name:'小米5s',value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'锤子T2', value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'锤子T1', value: 4, type: 4, date: '2018-06-07T08:06:01.589Z' },\n   {name:'魅蓝note5', value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'魅蓝note2', value: 5, type: 4, date: '2018-06-02T08:07:01.589Z' },\n   {name:'魅蓝note2', value: 6, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'魅蓝note3', value: 1, type: 4, date: '2018-06-05T08:00:01.589Z' },\n   {name:'魅蓝note', value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'oppor9', value: 7, type: 4, date: '2018-06-04T08:04:01.588Z' },\n   {name:'华为p9', value: 1, type: 4, date: '2018-06-02T08:00:01.577Z' },\n   {name:'华为p9', value: 2, type: 4, date: '2018-06-07T08:00:01.110Z' },\n   {name:'华为p10', value: 1, type: 1, date: '2018-06-07T08:00:01.534Z' }\n\n];\n```\n\n### 上期的答案\n#### 第一题\n> 如何从10000个数中找到最大的10个数\n\n创建一个最小堆结构，初始值为10000个数的前10个，堆顶为10个数里的最小数。然后遍历剩下的9990个数，如果数字小于堆顶的数，则直接丢弃，否则把堆顶的数删除，将遍历的数插入堆中，堆结构进行自动调整，所以可以保证堆顶的数一定是10个数里最小的。遍历完毕后，堆里的10个数就是这10000个数里面最大的10个。\n\n#### 第二题\n> 写个程序把 entry 转换成如下对象\n\n```js\nvar entry = {\n  'a.b.c.dd': 'abcdd',\n  'a.d.xx': 'adxx',\n  'a.e': 'ae'\n}\n\n// 要求转换成如下对象\nvar output = {\n  a: {\n   b: {\n     c: {\n       dd: 'abcdd'\n     }\n   },\n   d: {\n     xx: 'adxx'\n   },\n   e: 'ae'\n  }\n}\n```\n\n```js\nconst entry = {\n  'a.b.c.dd': 'abcdd',\n  'a.d.xx': 'adxx',\n  'a.e': 'ae',\n};\nconst changObjStructureOfNormal = output => {\n  const keys = Object.keys(output);\n  const resObj = {};\n  for (const key of keys) {\n    const everyKey = key.split('.');\n    everyKey.reduce((pre, next, index, array) => {\n      if (index === array.length - 1) {\n        pre[next] = output[key];\n        return;\n      }\n      pre[next] = pre[next] || {};\n      return pre[next];\n    }, resObj);\n  }\n  return resObj;\n};\nchangObjStructureOfNormal(entry);\n```","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-05-27T16:25:32.857Z","updatedAt":"2021-06-02T15:19:37.823Z","trashed":false,"_rev":"MH1l-OfPe"}