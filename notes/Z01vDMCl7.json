{"_id":"note:Z01vDMCl7","title":"compose","content":"## 代码组合（`compose`）\n\n```js\nvar compose = function(f,g) {\n  return function(x) {\n    return f(g(x));\n  };\n};\n```\n`f`和`g`都是函数，`x`是在它们之间通过“管道”传输的值。\n\n在`compose`的定义中，`g`将先于`f`执行，因此就创建了一个从右到左的数据流。这样做的可读性远远高于嵌套一大堆的函数调用，如果不用组合，`shout`函数将会是这样的：\n\n```js\nvar shout = function(x){\n  return exclaim(toUpperCase(x));\n};\n```\n\n让代码从右向左运行，而不是由内而外运行，我觉得可以称之为“左倾”（吁——）。我们来看一个顺序很重要的例子：\n\n```js\nvar head = function(x) { return x[0]; };\nvar reverse = reduce(function(acc, x){ return [x].concat(acc); }, []);\nvar last = compose(head, reverse);\n\nlast(['jumpkick', 'roundhouse', 'uppercut']);\n//=> 'uppercut'\n```\n\n尽管我们可以定义一个从左向右的版本，但是从右向左执行更加能够反映数学上的含义——是的，组合的概念直接来自于数学课本。实际上，现在是时候去看看所有的组合都有的一个特性了。\n\n```js\n// 结合律（associativity）\nvar associative = compose(f, compose(g, h)) == compose(compose(f, g), h);\n// true\n```\n\n### `pointfree`\n`pointfree`模式指的是，永远不必说出你的数据\n\n```js\n// 非 pointfree，因为提到了数据：word\nvar snakeCase = function (word) {\n  return word.toLowerCase().replace(/\\s+/ig, '_');\n};\n\n// pointfree\nvar snakeCase = compose(replace(/\\s+/ig, '_'), toLowerCase);\n```\n\n看到`replace`是如何被局部调用的了么？这里所做的事情就是通过管道把数据在接受单个参数的函数间传递。利用`curry`，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。另外注意在`pointfree`版本中，不需要`word`参数就能构造函数；而在非`pointfree`的版本中，必须要有`word`才能进行一切操作。\n\n我们再来看一个例子。\n```js\n// 非 pointfree，因为提到了数据：name\nvar initials = function (name) {\n  return name.split(' ').map(compose(toUpperCase, head)).join('. ');\n};\n\n// pointfree\nvar initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));\n\ninitials(\"hunter stockton thompson\");\n// 'H. S. T'\n```\n\n另外，`pointfree`模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，`pointfree`是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。比如，`while`循环是不能组合的。不过你也要警惕，`pointfree`就像是一把双刃剑，有时候也能混淆视听。并非所有的函数式代码都是 `pointfree`的，不过这没关系。可以使用它的时候就使用，不能使用的时候就用普通函数。","tags":[],"folderPathname":"/font/函数式","data":{},"createdAt":"2021-04-07T02:53:54.802Z","updatedAt":"2021-04-07T03:20:06.343Z","trashed":false,"_rev":"KYThyAk8G"}