{"title":"前端面试1","content":"http://bigerfe.com/\n\n## css\n- 盒模型（box-sizing）\n  - border ie\n  - padding firfox\n  - content w3c标准\n  - margin 未实现\n---\n- bfc\n  - 概念\n    - 内部元素与外部元素相互隔离（BFC内的元素不会影响外部元素布局）\n  - 发生条件\n    - flex box: flex/inline-flex\n    - overflow: 除visible\n    - 绝对定位: absolute fixed \n    - float: 除了none\n    - 行内元素: display: inline-block table-ceil table\n  - 使用场景\n    - 解决高度塌陷\n    - margin合并\n---\n- 居中\n  - `text-align: center`\n  - `margin: 0 auto`\n  - `absolute, calc/transform`\n  - `table: align valign`\n---\n- BEM 命名规范\n  - block element modifier\n  - `.sub-block__element {} .sub-block--modifier {}`\n---\n- 选择器优先级\n  - important 行内 id class target * 继承 默认\n---\n- 去除浮动，高度塌陷\n  - 创建bfc\n  - :after clear:both\n  - 父级设置高度\n---\n- link 与 @import 的区别\n  - link 支持 rss 定义rel, @import只支持 css\n    - rel关系： 如icon `<link rel=\"icon\" href=\"favicon.ico\">`\n  - @import需要 IE5 以上才能使用\n  - link可以使用 js 动态引入，@import不行\n---\n- css预处理\n  - 自动加前缀\n  - mixin复用\n    - sass `@mixin border{}声明 .container {@include border}引用`\n    - less `.card {} .container{@include border}`\n  - 继承\n    - sass .container{&:extend(.card)}\n    - less .container{@extend .card}\n  - 单位转换\n  - 变量\n  - 循环\n  - 条件\n  - 嵌套\n---\n- transition过度动画\n---\n---\n## HTTP/HTTPS\n- 无状态、无连接、简单\n---\n- 缺陷\n  - 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手\n  - head of line blocking: 线头阻塞，导致请求之间互相影响\n---\n- 1.1改进\n  - keep-alive 实现长连接复用\n  - host 字段指定对应的虚拟站点\n  - 断点续传\n  - 身份认证\n  - 状态管理\n  - cache 缓存\n---\n- 2.0\n  - 多路复用\n  - 二进制分帧层: 应用层和传输层之间\n  - 首部压缩\n  - 服务端推送\n---\n- https\n  - 较为安全的网络传输协议\n  - 证书(公钥)\n  - SSL 加密\n  - 端口 443\n---\n- tcp\n  - 三次握手 四次挥手\n  - 滑动窗口: 流量控制\n  - 拥塞处理\n    - 慢开始\n    - 拥塞避免\n    - 快速重传\n    - 快速恢复\n---\n- 缓存策略\n  - Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires\n  - 当缓存已经过期时，使用协商缓存,\n    - 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改\n    - 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)\n      - 如果一致，则直接返回 304 通知浏览器使用缓存\n      - 如不一致，则服务端返回新的资源\n  - Last-Modified 缺点：\n    - 周期性修改，但内容未变时，会导致缓存失效\n    - 最小粒度只到 s， s 以内的改动无法检测到\n  - Etag 的优先级高于 Last-Modified\n---\n- 状态码\n  - 1xx: 接受，继续处理\n  - 200: 成功，并返回数据\n  - 201: 已创建\n  - 202: 已接受\n  - 203: 成功，但未授权\n  - 204: 成功,但未返回结果\n  - 205: 成功，重置内容\n  - 206: 成功，部分内容\n  - 301: 永久移动，重定向\n  - 302: 临时移动，可使用原有URI\n  - 304: 资源未修改，可使用缓存\n  - 305: 需代理访问\n  - 400: 请求语法错误\n  - 401: 要求身份认证\n  - 403: 拒绝请求\n  - 404: 资源不存在\n  - 500: 服务器错误\n---\n- get / post\n---\n- websocket\n  - 持久化的协议， 基于 http ， 服务端可以 主动 push\n  - 兼容：\n    - FLASH Socket\n    - 长轮询： 定时发送 ajax\n    - long poll： 发送 --> 有消息时再 response\n  ```js\n  new WebSocket(url)\n  ws.onerror = fn\n  ws.onclose = fn\n  ws.onopen = fn\n  ws.onmessage = fn\n  ws.send()\n  ```\n---\n- TCP三次握手\n  - 客户端sync(Synchronize同步)信号，进入sync_send状态\n  - 服务端接收sync信号，发送sync+ack(确认字符Acknowledge)，进入sync_recv\n  - 客户端接收sync+ack,发送ack,进入established\n---\n- TCP四次挥手\n  - 客户端 -- FIN --> 服务端， FIN—WAIT\n  - 服务端 -- ACK --> 客户端， CLOSE-WAIT\n  - 服务端 -- ACK,FIN --> 客户端， LAST-ACK\n  - 客户端 -- ACK --> 服务端，CLOSED\n---\n- node Event Loop: 6个阶段\n  - timer:  执行到期的setTimeout / setInterval队列回调\n  - I/O 阶段: 执行上轮循环残流的callback\n  - idle, prepare\n  - poll: 等待回调\n    - 执行回调\n    - 执行定时器\n      - 如有到期的setTimeout / setInterval， 则返回 timer 阶段\n      - 如有setImmediate，则前往 check 阶段\n  - check\n    - 执行setImmediate\n  - close callbacks (socket.close)\n---\n- 跨域\n  - JSONP: 利用`<script>`标签不受跨域限制的特点，缺点是只能支持 get 请求\n  - 设置 CORS: Access-Control-Allow-Origin：*\n  - postMessage\n  - hash iframe\n---\n- 安全\n  - XSS攻击: 注入恶意代码\n    - cookie 设置 httpOnly\n    - 转义页面上的输入内容和输出内容\n  - CSRF: 跨站请求伪造，防护:\n    - get 不修改数据\n    - 不被第三方网站访问到用户的 cookie\n    - 设置白名单，不被第三方网站请求\n    - 请求校验\n---\n---\n## js\n- 原型\n  - 对象 用于实现对象的属性基础\n  - 每一个js对象都有一个__proto__指向父对象的原型\n---\n- 构造函数\n  - 可以通过new来新建一个对象的函数\n---\n- 实例\n  - 通过new创造出来的对象，通过__proto__指向原型，通过constructor指向构造函数\n![1](https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n---\n- 原型链\n  - 用来实现继承和共享属性\n---\n- 执行上下文\n  - 可理解为一个对象\n  - 包含：变量对象 this 作用域链\n  - 类型：全局执行上下文 函数执行上下文 eval执行上下文\n  - 代码执行过程\n    - 创建全局上下文\n    - 全局上下文（caller)自上而下执行，遇到函数，函数上下文被(callee)push到执行栈顶部\n    - 函数上下文被激活，开始执行函数中的代码，caller被挂起\n    - 函数执行完毕，callee被pop出执行栈，控制权交还给执行上下文，继续执行\n  - 变量对象\n    - 执行上下文的一部分，可以抽象成为一种数据作用域或简单的对象，储存着所有执行上下文的变量和函数声明（不包括函数表达式）\n  - 作用域\n    - 该上下文中声明的变量和声明\n    - 可分为块作用域、函数作用域\n    - 特性\n      - 声明提升：一个声明在函数体内都是可见的, 函数优先于变量\n      - 非匿名自执行函数，函数变量为 只读 状态，无法修改\n    - `[[scope]]`属性: 指向父级变量对象和作用域链，也就是包含了父级的`[[scope]]`和AO\n  - 作用域链\n    - 对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数\n---\n- 闭包\n  - 闭包属于一种特殊的作用域，称为 静态作用域\n  - 父函数被销毁的情况下，返回出的子函数还保留着父级的变量和作用域链，还可以访问父级的变量对象\n  - 多个子函数的`[[scope]]`都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。\n  - 解决\n    - 变量可以通过 函数参数的形式 传入，避免使用默认的`[[scope]]`向上查找\n    - 使用setTimeout包裹，通过第三个参数传入\n    - 使用 块级作用域，让变量成为自己上下文的属性，避免共享\n---\n- js引入方式\n  - html 静态`<script>`引入\n  - js 动态插入`<script>`\n  - `<script defer>`: 延迟加载，元素解析完成后执行\n  - `<script async>`: 异步加载，但执行时会阻塞元素渲染\n- 对象的拷贝\n  - 浅拷贝：以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响\n    - Object.assign\n    - 展开运算符(`...`)\n  - 深拷贝：完全拷贝一个新对象，修改时原对象不再受到任何影响\n    - JSON.parse(JSON.stringify(obj))\n      - 性能最快\n      - 具有循环引用对象时出错\n      - 当值是function undefined symbol 无法拷贝\n    - 递归进行逐一赋值\n---\n- new运算符的操作过程\n  - 创建新对象\n  - 链接到原型`foo.__proto__ = con.prototype`\n  - 绑定this\n  - 返回新对象\n---\n- instanceof原理\n  - 实例的原型对象链中能找到实例的构造函数的原型\n---\n- 代码复用\n  - 函数封装\n  - 继承\n  - mixin\n  - 借用（apply/call）\n---\n- 继承\n  - 原型链继承\n  - 通过原型链继承原型上的属性或者方法\n  - 圣杯模式\n  - 使用 ES6 的语法糖 class / extends\n---\n- 类型转换\n  - 数字 + 对象， 优先调用对象的valueOf -> toString\n  - 数字 + boolean/null -> 数字\n  - 数字 + undefined -> NaN\n  - [1].toString() === '1'\n  - {}.toString() === '[object object]'\n  - +undefined 为 NaN\n---\n- 类型判断\n  - 基本类型(null): 使用 String(null)\n  - 基本类型(string / number / boolean / undefined) + function: 直接使用 typeof即可,其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断，还可以通过instance.construct.name\n---\n- 模块化\n  - 分类\n    - es6: import/export\n    - commentjs: require/modules.exports/exports\n    - amd: require/defined\n  - require与import的区别\n    - require支持 动态导入，import不支持，正在提案 (babel 下可支持)\n    - require是 同步 导入，import属于 异步 导入\n    - require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化\n---\n- 防抖与节流\n  - 防抖 (debounce): 将多次高频操作优化为只在最后一次执行（用户输入）\n  - 节流(throttle)：每隔一段时间后执行一次，也就是降低频率， 滚动条事件 或者 resize 事件\n---\n- 函数执行改变this\n```js\ncall: fn.call(target, 1, 2)\napply: fn.apply(target, [1, 2])\nbind: fn.bind(target)(1,2)\n``` \n---\n- AST\n  - 抽象语法树,将代码逐字母解析成 树状对象 的形式\n---\n- babel编译原理\n  - babylon将 ES6/ES7 代码解析成 AST\n  - babel-traverse 对 AST 进行遍历转译，得到新的 AST\n  - 新 AST 通过 babel-generator 转换成 ES5\n---\n- 函数柯里化\n  - 在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。\n---\n---\n## 浏览器\n- 跨标签页通讯\n  - 通过父页面window.open()和子页面postMessage\n    - 异步下，通过 window.open('about: blank') 和 tab.location.href = '*'\n  - 设置同域下共享的localStorage与监听window.onstorage\n    - 重复写入相同的值无法触发\n    - 会受到浏览器隐身模式等的限制\n  - 设置共享cookie与不断轮询脏检查(setInterval)\n  - 借助服务端或者中间层实现\n---\n- 浏览器架构\n  - 用户界面\n  - 主进程\n  - 内核\n    - 渲染引擎\n    - JS 引擎\n      - 执行栈\n    - 事件触发线程\n      - 消息队列\n    - 网络异步线程\n    - 定时器线程\n---\n- 浏览器下事件循环\n  - 事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表\n  - 微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)\n  - 宏任务 macrotask(task): setTimout / script / IO / UI Rendering\n---\n- 从输入 url 到展示的过程\n  - DNS解析\n  - TCP三次握手\n  - 发送请求，解析URL，设置请求报文(头，主体)\n  - 服务端返回html\n  - 浏览器渲染\n    - HTML parser --> DOM Tree\n      - 标记化算法，进行元素状态的标记\n      - dom 树构建\n    - CSS parser --> Style Tree\n      - 解析 css 代码，生成样式树\n    - attachment --> Render Tree\n      - 结合 dom树 与 style树，生成渲染树\n    - layout: 布局\n    - GPU painting: 像素绘制页面\n---\n- 重绘与回流\n  - 当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素\n    - 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少\n    - 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。\n    - 触发回流\n      - 初次渲染\n      - 浏览器窗口大小改变\n      - 元素尺寸、位置、内容发生改变\n      - 元素字体大小变化\n      - 添加或者删除可见的 dom 元素\n      - 激活 CSS 伪类（例如：:hover）\n      - 查询某些属性或调用某些方法：clientWidth、clientHeight、clientTop、clientLeft\noffsetWidth、offsetHeight、offsetTop、offsetLeft\nscrollWidth、scrollHeight、scrollTop、scrollLeft\ngetComputedStyle()\ngetBoundingClientRect()\nscrollTo()\n  - 最佳实践\n    - css\n      - 避免使用table布局\n      - 将动画效果应用到position属性为absolute或fixed的元素上\n    - js\n      - 避免频繁操作样式，可汇总后统一 一次修改\n      - 尽量使用class进行样式修改\n      - 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入\n      - 极限优化时，修改样式可将其display: none后修改\n      - 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住\n---\n- 存储\n  - 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用\n  - 持久性存储，可以分为 浏览器端 与 服务器端\n    - 浏览器\n      - cookie: 通常用于存储用户身份，登录状态等\n        - http 中自动携带， 体积上限为 4K， 可自行设置过期时间\n      - localStorage / sessionStorage: 长久储存/窗口关闭删除， 体积限制为 4~5M\n      - indexDB\n        - 键值对储存\n        - 异步\n        - 支持事务,这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况\n        - 同源限制 IndexedDB 受到同源限制，每一个数据库对应创建它的域名\n        - 储存空间大 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限\n        - 支持二进制储存\n      - 服务器\n        - 分布式缓存 redis\n        - 数据库\n---\n- web worker\n  - 现代浏览器为JavaScript创造的 多线程环境\n  - 可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信\n  ```js\n    // 创建 worker\n    const worker = new Worker('work.js');\n\n    // 向 worker 线程推送消息\n    worker.postMessage('Hello World');\n\n    // 监听 worker 线程发送过来的消息\n    worker.onmessage = function (event) {\n      console.log('Received message ' + event.data);\n    }\n  ```\n  - 限制\n    - 同源访问\n    - 无法获取本地资源\n    - 无法使用document window alert confirm\n---\n- V8垃圾回收机制\n  - 将内存中不再使用的数据进行清理，释放出内存空间\n  - 将内存分成 新生代空间 和 老生代空间\n    - 新生代空间: 用于存活较短的对象\n      - 分成两个空间: from 空间 与 to 空间\n        - Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法\n          - 存活的对象从 from space 转移到 to space\n          - 清空 from space\n          - from space 与 to space 互换\n          - 完成一次新生代GC\n    - 老生代空间: 用于存活时间较长的对象\n      - 从 新生代空间 转移到 老生代空间 的条件\n        - 经历过一次以上 Scavenge GC 的对象\n        - 当 to space 体积超过25%\n      - 标记清除算法: 标记存活的对象，未被标记的则被释放\n        - 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能\n        - 并发标记(最新技术): 不阻塞 js 执行\n      - 压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化\n---\n- 内存泄露\n  - 意外的全局变量: 无法被回收\n  - 定时器: 未被正确关闭，导致所引用的外部变量无法被释放\n  - 事件监听: 没有正确销毁 (低版本浏览器可能出现)\n  - 闭包: 会导致父级中的变量无法被释放\n  - dom 引用: dom 元素被删除时，内存中的引用未被正确清空\n---\n---\n## 算法\n- 排序\n  - 冒泡：两两比较\n  - 选择：遍历自身以后的元素，最小的元素跟自己调换位置\n  - 插入: 即将元素插入到已排序好的数组中\n  - 快排\n    - 选择基准值(base)，原数组长度减一(基准值)，使用 splice\n    - 循环原数组，小的放左边(left数组)，大的放右边(right数组);\n    - concat(left, base, right)\n    - 递归继续排序 left 与 right\n  - 希尔：不定步数的插入排序，插入排序\n---\n---\n## webpack\n- 模块打包工具，通过分析模块间的依赖，将模块打包成一个或多个bunder,共html直接引用\n- loader\n  - 由于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对 不同格式文件转换器\n  - 对 Webpack 传入的字符串进行按需修改\n  - 实际的 Loader 不会这么简单，通常是需要将代码进行分析，构建 AST (抽象语法树)\n  - 特性\n    - 链式传递，按照配置时相反的顺序链式执行\n    - 基于 Node 环境，拥有 较高权限，比如文件的增删查改；\n    - 可同步也可异步；\n  - 常用 Loader\n    - file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能；\nurl-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；\nbabel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；\nts-loader: 加载 ts / tsx 文件，编译 TypeScript；\nstyle-loader: 将 css 代码以`<style>`标签的形式插入到 html 中；\ncss-loader: 分析@import和url()，引用 css 文件与对应的资源；\npostcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 添加前缀，单位转换 等；\nless-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率；\n    - 编写原则\n      - 单一原则: 每个 Loader 只做一件事\n      - 链式调用: Webpack 会按顺序链式调用每个 Loader；\n      - 统一原则: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；\n- Plugin\n  - Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改\n  - 注册： new Plugin(options),\n  - 常用plugin\n    - UglifyJsPlugin: 压缩、混淆代码；\n    - CommonsChunkPlugin: 代码分割；\n    - ProvidePlugin: 自动加载模块；\n    - html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；\n---\n---\n## React\n- fiber：实现任务的分割\n  - reconcilation(调度算法，也称render)\n    - 更新state和props\n    - 调用生命周期\n    - 生成virtual tree（fiber tree）\n    - 通过旧的vdom 生成新的 vdom change\n    - 确定是否需要渲染\n  - commit\n    - 如有需要,则进行dom操作\n  - 分散执行\n    - 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新API: requestIdleCallback 与 requestAnimationFrame\n---\n- 生命周期\n  - 使用getDerivedStateFromProps 替换 componentWillMount 与 componentWillReceiveProps\n  - 使用getSnapshotBeforeUpdate替换componentWillUpdate；\n  - 使用建议\n    - 在constructor初始化 state；\n    - 在componentDidMount中进行事件监听，并在componentWillUnmount中解绑事件；\n    - 在componentDidMount中进行数据的请求，而不是在componentWillMount；\n    - 需要根据 props 更新 state 时，使用getDerivedStateFromProps(nextProps, prevState)\n---\n- setState\n  - React 中用于修改状态，更新视图\n  - 异步与同步\n    - 在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是\"异步\"的,如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值\n    - 在 原生事件 和 setTimeout 中，setState是同步的，可以马上获取更新后的值\n  - 批量更新(Object.assign)\n  - 函数式:setState(fn),可以用于避免setState的批量更新的逻辑，传入的函数将会被 顺序调用\n---\n- HOC\n  - 增强函数，可以输入一个元组件，返回出一个新的增强组件\n  - 主要作用是 代码复用，操作 状态和参数\n  - 用法\n    - 属性代理\n    - 状态提取\n    - 包裹组件\n    - 条件渲染\n  - 应用场景\n    - 权限控制\n    - 性能监控（埋点）\n    - 代码复用\n---\n- Redux\n  - 概念\n    - 单一数据源\n    - 状态只读\n    - 纯函数\n- React Hook\n  - 好处\n    - 跨组件复用\n    - 类定义更为复杂\n    - 状态与UI隔离\n  ","tags":[],"folderPathname":"/font/面试","data":{},"createdAt":"2020-10-09T16:06:28.542Z","updatedAt":"2021-01-04T09:06:30.724Z","trashed":false,"_id":"note:xUuq37UL2","_rev":"12-372f8d26cf4f50dec9119b4a0486dd3e"}