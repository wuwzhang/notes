{"_id":"note:v864F42JX","title":"第48期","content":"## 2021/06/04\n## 每周资讯 - 第`48`期\n### 1. [使用Javascript制作BadApple字符画视频](https://juejin.cn/post/6953029932968574984)\n\n##### 制作一个`BadApple`效果\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f1e414511d4768b6e28f7e4da09eb3~tplv-k3u1fbpfcp-watermark.image)\n\n- 先拆解需求\n  - 播放视频\n  - 将视频每一帧的画面转为点阵/像素RGB值\n  - 将RGB转灰度值\n  - 按照灰度值填充字符\n\n#### 1. 播放视频\n使用JS创建一个video标签，并为它设置视频源路径\n```js\nvar videoDom = document.createElement(\"video\");\nvideoDom.src = \"./video/badapple.mp4\";\nvideoDom.style.width = \"900px\";\nvideoDom.style.height = \"675px\";\n```\n由于我们最终的效果并不需要看到这个视频原画面，所以我们也不用将这个dom添加到网页body当中去。\n\n添加一个控制视频播放和暂停的按钮\n\n```js\nvar btnPlayAndPause = document.createElement(\"div\");\nbtnPlayAndPause.style.color = \"#fff\";\nbtnPlayAndPause.style.textAlign = \"center\";\nbtnPlayAndPause.style.position = \"absolute\";\nbtnPlayAndPause.style.top = btnPlayAndPause.style.left = \"0px\";\nbtnPlayAndPause.style.width = videoDom.style.width;\nbtnPlayAndPause.style.height = btnPlayAndPause.style.lineHeight = videoDom.style.height;\nbtnPlayAndPause.style.cursor = \"pointer\";\nbtnPlayAndPause.style.fontSize = \"30px\";\nbtnPlayAndPause.style.zIndex = 2;\nbtnPlayAndPause.innerText = \"play\";\ndocument.body.appendChild(btnPlayAndPause);\n```\n\n当按钮点击的时候，切换videoDom的播放/暂停状态\n```js\nbtnPlayAndPause.addEventListener(\"click\", function () {\n  if (btnPlayAndPause.innerText === \"play\") {\n    videoDom.play();\n  } else {\n    videoDom.pause();\n  }\n});\n```\n\n监听videoDom的canplay事件，并渲染第一帧\n```js\nvideoDom.addEventListener('canplay',function(){\n  renderVideoFrame(videoDom);\n});\n```\n监听videoDom的play（播放），pause（暂停），stop（停止）事件在播放时启动字符画面渲染，暂停或停止时也停止掉字符画面渲染。\n\n```js\nvideoDom.addEventListener(\"play\", function () {\n  console.log(\"开始播放\");\n  btnPlayAndPause.innerText = \"\";\n\n  startRender();\n});\n\n//监听播放结束\nvideoDom.addEventListener(\"pause\", function () {\n  console.log(\"播放暂停\");\n  btnPlayAndPause.innerText = \"play\";\n\n  stopRender();\n});\n\n//监听播放结束\nvideoDom.addEventListener(\"ended\", function () {\n  console.log(\"播放结束\");\n  btnPlayAndPause.innerText = \"play\";\n\n  stopRender();\n});\n```\n\n画面渲染的绘制频率和浏览器的绘制频率保持一致，这样不会丢掉任何一个画面，但算力消耗会更大。\n\n```js\nvar timerId;\nfunction startRender() {\n  timerId = requestAnimationFrame(updateRender);\n}\nfunction updateRender() {\n  renderVideoFrame(videoDom);\n  timerId = requestAnimationFrame(updateRender);\n}\nfunction stopRender() {\n  cancelAnimationFrame(timerId);\n}\n```\n\n#### 2. 将视频每一帧的画面转为点阵/像素RGB值\n```js\nfunction renderVideoFrame(videoDom) {\n  var videoSize = {\n    width: parseFloat(videoDom.videoWidth),\n    height: parseFloat(videoDom.videoHeight),\n  };\n\n  var canvas = document.querySelector(\"#canvas\");\n  if (!canvas) {\n    canvas = document.createElement(\"canvas\");\n    canvas.id = \"canvas\";\n    canvas.style.width = videoDom.style.width;\n    canvas.style.height = videoDom.style.height;\n    canvas.style.position = \"absolute\";\n    canvas.style.zIndex = 1;\n    canvas.style.left = canvas.style.top = \"0\";\n    canvas.width = videoSize.width;\n    canvas.height = videoSize.height;\n\n    document.body.appendChild(canvas);\n  }\n\n  const ctx = canvas.getContext(\"2d\");\n\n  ctx.drawImage(videoDom, 0, 0, videoSize.width, videoSize.height);\n}\n```\n\n注意看我这里做了判断，只在场景上没有指定canvas的时候，才创建它。\n\n接着通过context的drawImage方法，将视频绘制到场景上，现在我们body虽然没有video标签，但我们也能看到视频了。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cb4eb71ce974534b971a088f6a437b4~tplv-k3u1fbpfcp-watermark.image)\n接着我们再通过context的getImageData方法，获得画布里的全部点阵/像素数据。\n```js\nvar imgData = ctx.getImageData(0, 0, videoSize.width, videoSize.height).data;\n```\n这是一个庞大的数组，数组的长度由`width*height*4`（宽度x高度x4）组成，4代表`RGBA`四个值。\n\n```js\n//如果这个画布是宽2个像素，高1个像素的话，那么getImageData获得数组结构如下\n[r,g,b,a,r,g,b,a]\n```\n\n这个理解了之后我们来看如何获得指定位置的RGBA值。\n\n```js\nfor (var h = 0; h < videoSize.height; h++) {\n  for (var w = 0; w < videoSize.width; w++) {\n    var position = (videoSize.width * h + w) * 4;\n    var r = imgData[position],\n      g = imgData[position + 1],\n      b = imgData[position + 2];\n  }\n}\n```\n\n通过画布宽度和高度的两次for循环，换算得出所有点阵/像素在数组中的起始序号。\n\n- r = imgData[position]\n- g = imgData[position + 1]\n- b = imgData[position + 2]\n\n大家可以看到，一块200x300的画布=6万个点阵=长度为24万的数组，我们肯定不能按照像素1：1来绘制，这样运算量过大，并且绘制出来的效果也不好，你根本看不清文字内容。\n\n所以我们要加入一个间隔，比如1：12，这样运算量大大减少，但是绘制出来的精度也会降低。\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7403183f88ec4e7d8e09e2c1d16d1871~tplv-k3u1fbpfcp-watermark.image)\n\n实现这个效果我们不需要alpha，接下来的重头戏是把RGB转为灰度值，灰度值再转化为笔画密度的文字，比如黑色的像素块我们就用猿这个字来替换。\n\n#### 3. RGB转灰度值\n> [RGB转灰度的各种算法](https://www.cnblogs.com/zhangjiansheng/p/6925722.html)请看这篇文章\n\n我采用了文中所列的第二种方法\n```js\nGray = (R*30 + G*59 + B*11 + 50) / 100 - 0.5\n```\n\n这个值在0.5-255.5之间\n\n#### 按照灰度值填充字符\n首先我们要建立一个灰度字符数组，按照笔画密度/视觉灰度（从高到低）排列，最后留一个空白字符去表现纯白色。\n\n```js\nvar asciiList = ['猿','帅','老','大', '　'];\n```\n\n将灰度值转为字符数组的序号，使用Math.min方法来确保序号不会越界\n\n```js\nvar i = Math.min(asciiList.length-1,parseInt(gray / (255 / asciiList.length)));\n```\n\n#### 总结\n这是一个自我接触计算机以来就知道的特效，我的职业历史上也用各种语言分别实现过。其实拆解需求后，核心就是获取画面点阵信息，RGB数据转灰度或者二值化（仅黑白两色）。再根据灰度信息替换为字符即可。\n\n希望我的这篇教程让你彻底学会，以后不管用什么语言，什么环境，找到对应的API，都能开发出来这个效果。\n\n#### 相关文章\n- [使用Javascript制作BadApple字符画视频](https://juejin.cn/post/6953029932968574984)\n\n### 2. [一个合格(优秀)的前端都应该阅读这些文章 JavaScript](https://juejin.cn/post/6844903896637259784)\n一个合格(优秀)的前端都应该阅读这些文章\n\n#### 相关文章\n- [一个合格(优秀)的前端都应该阅读这些文章 JavaScript](https://juejin.cn/post/6844903896637259784)\n\n## 30 seconds of code\n### 目标\n实现以下`useUnload` hooks \n### 样例输出: \n```js\nconst App = () => {\n  useUnload(e => {\n    e.preventDefault();\n    const exit = confirm('Are you sure you want to leave?');\n    if (exit) window.close();\n  });\n  return <div>Try closing the window.</div>;\n};\nReactDOM.render(<App />, document.getElementById('root'));\n```\n### 参考实现\n```js\nconst useUnload = fn => {\n  const cb = React.useRef(fn);\n\n  React.useEffect(() => {\n    const onUnload = cb.current;\n    window.addEventListener('beforeunload', onUnload);\n    return () => {\n      window.removeEventListener('beforeunload', onUnload);\n    };\n  }, [cb]);\n};\n```\n## 每日一问\n> 以下代码的运行结果为\n\n```js    \nconst clothes = ['jacket', 't-shirt'];\nclothes.length = 0;\n\nclothes[0]; \n```\n\n## 每日二问\n> 找出字符串中连续出现最多的字符和个数\n\n\n### 上期的答案\n#### 第一题\n> git cherry-pick，有什么作用？\n\ngit cherry-pick可以理解为”挑拣”提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。 当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用git cherry-pick了。\n\n```shell\ngit cherry-pick [<options>] <commit-ish>...\n\n# 常用 options:\n    --quit               # 退出当前的chery-pick序列\n    --continue           # 继续当前的chery-pick序列\n    --abort              # 取消当前的chery-pick序列，恢复当前分支\n    -n, --no-commit      # 不自动提交\n    -e, --edit           # 编辑提交信息\n```\n\n``` shell\n# demo\n# 在branch1上查看commit的id,例如是8d63abdcf7c331a5c29e392fa1fa85a2161cbdf4,\n# 然后切换到master分支,执行cherrt-pick\n\ngit checkout master\ngit cherry-pick 8d63abdcf7c331a5c29e392fa1fa85a2161cbdf4\n```\n\n#### 第二题\n> 完成以下功能\n\n- 请用您认为最优化的方式，将arr中的type为4的数据过滤出来\n- 然后按相同的 name date（按天）合并value（value累加）\n- 然后按 value 降序(从大到小)排序\n- 最后每行按照 \"${name},${本地日期},售出${sum(value)}部\" 的格式，如：\"小米2,2017年06月08日,售出5部\", 打印(console.log)出来。可以使用es6。\n\n```js\nvar arr = [\n   {name:'小米1', value: 1,  type: 2, date: '2018-06-07T08:00:01.589Z' },\n   {name:'锤子T1', value: 1, type: 2, date: '2018-06-07T08:10:01.589Z' },\n   {name:'小米2', value: 1, type: 4, date: '2018-06-07T20:00:01.589Z' },\n   {name:'小米2', value: 4, type: 4, date: '2018-06-07T20:10:21.189Z' },\n   {name:'小米4', value: 1, type: 4, date: '2018-06-07T08:00:01.560Z' },\n   {name:'小米4', value: 2, type: 4, date: '2018-06-07T08:10:31.584Z' },\n   {name:'小米6', value: 1, type: 3, date: '2018-06-07T08:00:01.589Z' },\n   {name:'小米5s',value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'锤子T2', value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'锤子T1', value: 4, type: 4, date: '2018-06-07T08:06:01.589Z' },\n   {name:'魅蓝note5', value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'魅蓝note2', value: 5, type: 4, date: '2018-06-02T08:07:01.589Z' },\n   {name:'魅蓝note2', value: 6, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'魅蓝note3', value: 1, type: 4, date: '2018-06-05T08:00:01.589Z' },\n   {name:'魅蓝note', value: 1, type: 4, date: '2018-06-07T08:00:01.589Z' },\n   {name:'oppor9', value: 7, type: 4, date: '2018-06-04T08:04:01.588Z' },\n   {name:'华为p9', value: 1, type: 4, date: '2018-06-02T08:00:01.577Z' },\n   {name:'华为p9', value: 2, type: 4, date: '2018-06-07T08:00:01.110Z' },\n   {name:'华为p10', value: 1, type: 1, date: '2018-06-07T08:00:01.534Z' }\n\n];\n```\n\n```js\n// 参考实现，不清楚最优解，欢迎一起探讨！！！\nObject.entries(\n  arr.reduce((a, c) => {\n    if (c.type === 4) {\n      const key = c.date?.split(\"T\")[0] + \"$$\" + c.name;\n      a[key] = (a[key] || 0) + c.value;\n    }\n    return a;\n  }, {})\n)\n  .sort((a, b) => b[1] - a[1])\n  .forEach((v) => {\n    const [date, name] = v[0].split('$$')\n    const d = date.split('-')\n    \n    console.log(`${name},${d[0]}年${d[1]}月${d[2]}日,售出${v[1]}部`)\n  });\n\n```\n\n","tags":[],"folderPathname":"/weekly","data":{},"createdAt":"2021-06-02T14:41:20.985Z","updatedAt":"2021-06-03T11:41:59.705Z","trashed":false,"_rev":"XLiKhuqEK"}