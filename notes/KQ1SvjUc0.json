{"_id":"note:KQ1SvjUc0","title":"大文件上传","content":"### 知识点\n- 文件上传原理\n- 最原始的文件上传\n- 使用`koa2`作为服务端写一个文件上传接口\n- 单文件上传和上传进度\n- 多文件上传和上传进度\n- 拖拽上传\n- 剪贴板上传\n- 大文件上传之分片上传\n- 大文件上传之断点续传\n- `node`端文件上传\n### 概念\n#### 秒传\n把要上传的东西上传，服务器会先做`MD5`校验，如果服务器上有一样的文件，就直接返回个新地址,下载的文件是服务器上的同一个文件\n\n#### 分片上传\n将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part），进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件\n\n#### 断点续传\n在上传时，将上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传，如果碰到网络故障，可以从已经上传的部分开始继续上传、未完成的部分，而没有必要从头开始上传\n\n#### 原理\n根据`http`协议的规范和定义，完成请求消息体的封装和消息体的解析，然后将二进制内容保存到文件\n\n我们都知道如果要上传一个文件，需要把`form`标签的`enctype`设置为`multipart/form-data`,同时`method`必须为`post`方法。\n\n那么`multipart/form-data`表示什么呢？\n> multipart互联网上的混合资源，就是资源由多种元素组成，form-data表示可以使用HTML Forms 和 POST 方法上传文件，具体的定义可以参考RFC 7578。\n\n`multipart/form-data`结构\n看下`http`请求的消息体\n![](https://user-gold-cdn.xitu.io/2019/10/16/16dd3d4c4d605f53?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n- 请求头：\n\n`Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryDCntfiXcSkPhS4PN`表示本次请求要上传文件，其中`boundary`表示分隔符，如果要上传多个表单项，就要使用`boundary`分割，每个表单项由———`XXX`开始，以———`XXX`结尾。\n\n- 消息体- `Form Data`部分\n\n每一个表单项又由`Content-Type`和`Content-Disposition`组成。\n`Content-Disposition: form-data`为固定值，表示一个表单元素，`name`表示表单元素的 名称，回车换行后面就是`name`的值，如果是上传文件就是文件的二进制内容。\n`Content-Type`：表示当前的内容的`MIME`类型，是图片还是文本还是二进制数据。\n\n#### 解析\n客户端发送请求到服务器后，服务器会收到请求的消息体，然后对消息体进行解析，解析出哪是普通表单哪些是附件。\n\n可能大家马上能想到通过正则或者字符串处理分割出内容，不过这样是行不通的，二进制`buffer`转化为`string`,对字符串进行截取后，其索引和字符串是不一致的，所以结果就不会正确，除非上传的就是字符串。\n\n不过一般情况下不需要自行解析，目前已经有很成熟的三方库可以使用。\n至于如何解析，这个也会占用很大篇幅，后面的文章在详细说。\n\n#### 最原始的文件上传\n使用`form`表单上传文件\n\n在`ie`时代，如果实现一个无刷新的文件上传那可是费老劲了，大部分都是用`iframe`来实现局部刷新或者使用 `lash`插件来搞定，在那个时代`ie`就是最好用的浏览器（别无选择）。\n![](https://user-gold-cdn.xitu.io/2019/10/16/16dd3b9b353b4bc7?imageslim)\n\n这种方式上传文件，不需要`js`，而且没有兼容问题，所有浏览器都支持，就是体验很差，导致页面刷新，页面其他数据丢失。\n\n```html\n<form method=\"post\" action=\"http://localhost:8100\" enctype=\"multipart/form-data\">\n    选择文件:\n    <input type=\"file\" name=\"f1\"/>\n    标题：\n    <input type=\"text\" name=\"title\"/>\n    <button type=\"submit\" id=\"btn-0\">上 传</button>\n</form>\n```\n\n#### 文件上传接口\n服务端文件的保存基于现有的库`koa-body`结合`koa2`实现服务端文件的保存和数据的返回。\n\n在项目开发中，文件上传本身和业务无关，代码基本上都可通用。\n在这里我们使用`koa-body`库来实现解析和文件的保存。\n\n`koa-body`会自动保存文件到系统临时目录下，也可以指定保存的文件路径。\n\n#### 前端\n前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 `Blob.prototype.slice`方法，和数组的`slice`方法相似，调用的`slice`方法可以返回原文件的某个切片\n\n这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 `http`的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间\n\n另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序\n\n#### 服务端\n服务端需要负责接受这些切片，并在接收到所有切片后合并切片\n这里又引伸出两个问题\n\n1. 何时合并切片，即切片什么时候传输完成\n2. 如何合并切片\n\n第一个问题需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并，也可以额外发一个请求主动通知服务端进行切片的合并\n第二个问题，具体如何合并切片呢？这里可以使用`nodejs`的 读写流（`readStream/writeStream`），将所有切片的流传输到最终文件的流里\n`talk is cheap,show me the code`，接着我们用代码实现上面的思路\n","tags":[],"folderPathname":"/font","data":{},"createdAt":"2021-05-07T07:17:27.880Z","updatedAt":"2021-05-07T08:33:54.691Z","trashed":false,"_rev":"dOHSmVgoO"}